// Generated by dts-bundle-generator v5.9.0
declare namespace PIXI {
  namespace particles {
  export interface EmitterConfigV3 {
    lifetime: RandNumber;
    ease?: SimpleEase | EaseSegment[];
    particlesPerWave?: number;
    frequency: number;
    spawnChance?: number;
    emitterLifetime?: number;
    maxParticles?: number;
    addAtBack?: boolean;
    pos: {
      x: number;
      y: number;
    };
    emit?: boolean;
    autoUpdate?: boolean;
    behaviors: {
      type: string;
      config: any;
    }[];
  }
  export interface RandNumber {
    max: number;
    min: number;
  }
  export function upgradeConfig(
    config: EmitterConfigV2 | EmitterConfigV1,
    art: any
  ): EmitterConfigV3;
  export interface EmitterConfigV2 {
    alpha?: ValueList<number>;
    speed?: ValueList<number>;
    minimumSpeedMultiplier?: number;
    maxSpeed?: number;
    acceleration?: {
      x: number;
      y: number;
    };
    scale?: ValueList<number>;
    minimumScaleMultiplier?: number;
    color?: ValueList<string>;
    startRotation?: RandNumber;
    noRotation?: boolean;
    rotationSpeed?: RandNumber;
    rotationAcceleration?: number;
    lifetime: RandNumber;
    blendMode?: string;
    ease?: SimpleEase | EaseSegment[];
    extraData?: any;
    particlesPerWave?: number;
    /**
     * Really "rect"|"circle"|"ring"|"burst"|"point"|"polygonalChain", but that
     * tends to be too strict for random object creation.
     */
    spawnType?: string;
    spawnRect?: {
      x: number;
      y: number;
      w: number;
      h: number;
    };
    spawnCircle?: {
      x: number;
      y: number;
      r: number;
      minR?: number;
    };
    particleSpacing?: number;
    angleStart?: number;
    spawnPolygon?: PIXI.IPointData[] | PIXI.IPointData[][];
    frequency: number;
    spawnChance?: number;
    emitterLifetime?: number;
    maxParticles?: number;
    addAtBack?: boolean;
    pos: {
      x: number;
      y: number;
    };
    emit?: boolean;
    autoUpdate?: boolean;
    orderedArt?: boolean;
  }
  export interface BasicTweenable<T> {
    start: T;
    end: T;
  }
  export interface EmitterConfigV1 {
    alpha?: BasicTweenable<number>;
    speed?: BasicTweenable<number> & {
      minimumSpeedMultiplier?: number;
    };
    maxSpeed?: number;
    acceleration?: {
      x: number;
      y: number;
    };
    scale?: BasicTweenable<number> & {
      minimumScaleMultiplier?: number;
    };
    color?: BasicTweenable<string>;
    startRotation?: RandNumber;
    noRotation?: boolean;
    rotationSpeed?: RandNumber;
    rotationAcceleration?: number;
    lifetime: RandNumber;
    blendMode?: string;
    ease?: SimpleEase | EaseSegment[];
    extraData?: any;
    particlesPerWave?: number;
    /**
     * Really "rect"|"circle"|"ring"|"burst"|"point"|"polygonalChain", but that
     * tends to be too strict for random object creation.
     */
    spawnType?: string;
    spawnRect?: {
      x: number;
      y: number;
      w: number;
      h: number;
    };
    spawnCircle?: {
      x: number;
      y: number;
      r: number;
      minR?: number;
    };
    particleSpacing?: number;
    angleStart?: number;
    spawnPolygon?: PIXI.IPointData[] | PIXI.IPointData[][];
    frequency: number;
    spawnChance?: number;
    emitterLifetime?: number;
    maxParticles?: number;
    addAtBack?: boolean;
    pos: {
      x: number;
      y: number;
    };
    emit?: boolean;
    autoUpdate?: boolean;
    orderedArt?: boolean;
  }
  export interface ValueStep<T> {
    value: T;
    time: number;
  }
  export interface ValueList<T> {
    list: ValueStep<T>[];
    isStepped?: boolean;
    ease?: SimpleEase | EaseSegment[];
  }
  /**
   * A single node in a PropertyList.
   */
  export class PropertyNode<V> {
    /**
     * Value for the node.
     */
    value: V;
    /**
     * Time value for the node. Between 0-1.
     */
    time: number;
    /**
     * The next node in line.
     */
    next: PropertyNode<V>;
    /**
     * If this is the first node in the list, controls if the entire list is stepped or not.
     */
    isStepped: boolean;
    ease: SimpleEase;
    /**
     * @param value The value for this node
     * @param time The time for this node, between 0-1
     * @param [ease] Custom ease for this list. Only relevant for the first node.
     */
    constructor(value: V, time: number, ease?: SimpleEase | EaseSegment[]);
    /**
     * Creates a list of property values from a data object {list, isStepped} with a list of objects in
     * the form {value, time}. Alternatively, the data object can be in the deprecated form of
     * {start, end}.
     * @param data The data for the list.
     * @param data.list The array of value and time objects.
     * @param data.isStepped If the list is stepped rather than interpolated.
     * @param data.ease Custom ease for this list.
     * @return The first node in the list
     */
    static createList<T extends string | number>(
      data: ValueList<T> | BasicTweenable<T>
    ): PropertyNode<T extends string ? Color : T>;
  }
  export function GetTextureFromString(s: string): PIXI.Texture;
  export interface Color {
    r: number;
    g: number;
    b: number;
    a?: number;
  }
  export interface EaseSegment {
    cp: number;
    s: number;
    e: number;
  }
  export type SimpleEase = (time: number) => number;
  /**
   * Contains helper functions for particles and emitters to use.
   */
  export namespace ParticleUtils {
    /**
     * If errors and warnings should be logged within the library.
     */
    const verbose = false;
    const DEG_TO_RADS: number;
    /**
     * Rotates a point by a given angle.
     * @param angle The angle to rotate by in radians
     * @param p The point to rotate around 0,0.
     */
    function rotatePoint(angle: number, p: PIXI.IPointData): void;
    /**
     * Combines separate color components (0-255) into a single uint color.
     * @param r The red value of the color
     * @param g The green value of the color
     * @param b The blue value of the color
     * @return The color in the form of 0xRRGGBB
     */
    function combineRGBComponents(r: number, g: number, b: number): number;
    /**
     * Reduces the point to a length of 1.
     * @param point The point to normalize
     */
    function normalize(point: PIXI.IPointData): void;
    /**
     * Multiplies the x and y values of this point by a value.
     * @param point The point to scaleBy
     * @param value The value to scale by.
     */
    function scaleBy(point: PIXI.IPointData, value: number): void;
    /**
     * Returns the length (or magnitude) of this point.
     * @param point The point to measure length
     * @return The length of this point.
     */
    function length(point: PIXI.IPointData): number;
    /**
     * Converts a hex string from "#AARRGGBB", "#RRGGBB", "0xAARRGGBB", "0xRRGGBB",
     * "AARRGGBB", or "RRGGBB" to an object of ints of 0-255, as
     * {r, g, b, (a)}.
     * @param color The input color string.
     * @param output An object to put the output in. If omitted, a new object is created.
     * @return The object with r, g, and b properties, possibly with an a property.
     */
    function hexToRGB(color: string, output?: Color): Color;
    /**
     * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated
     * by the related tool at http://www.greensock.com/customease/.
     * @param segments An array of segments, as created by
     * http://www.greensock.com/customease/.
     * @return A function that calculates the percentage of change at
     *                    a given point in time (0-1 inclusive).
     */
    function generateEase(segments: EaseSegment[]): SimpleEase;
    /**
     * Gets a blend mode, ensuring that it is valid.
     * @param name The name of the blend mode to get.
     * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.
     */
    function getBlendMode(name: string): number;
    /**
     * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly
     * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of
     * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.
     * @param list The list of data to convert.
     * @param [numSteps=10] The number of steps to use.
     * @return The blend mode as specified in the PIXI.blendModes enumeration.
     */
    function createSteppedGradient(
      list: ValueStep<string>[],
      numSteps?: number
    ): PropertyNode<Color>;
  }
  export interface IEmitterBehavior {
    order: number;
    initParticles(first: Particle): void;
    updateParticle?(particle: Particle, deltaSec: number): void | boolean;
    recycleParticle?(particle: Particle, natural: boolean): void;
  }
  export interface IEmitterBehaviorClass {
    type: string;
    new (config: any): IEmitterBehavior;
  }
  const PositionParticle: unique symbol;
  /**
   * A particle emitter.
   */
  export class Emitter {
    private static knownBehaviors;
    static registerBehavior(constructor: IEmitterBehaviorClass): void;
    /**
     * Active initialization behaviors for this emitter.
     */
    protected initBehaviors: (IEmitterBehavior | typeof PositionParticle)[];
    /**
     * Active update behaviors for this emitter.
     */
    protected updateBehaviors: IEmitterBehavior[];
    /**
     * Active recycle behaviors for this emitter.
     */
    protected recycleBehaviors: IEmitterBehavior[];
    /**
     * The minimum lifetime for a particle, in seconds.
     */
    minLifetime: number;
    /**
     * The maximum lifetime for a particle, in seconds.
     */
    maxLifetime: number;
    /**
     * An easing function for nonlinear interpolation of values. Accepts a single
     * parameter of time as a value from 0-1, inclusive. Expected outputs are values
     * from 0-1, inclusive.
     */
    customEase: SimpleEase;
    /**
     * Time between particle spawns in seconds.
     */
    protected _frequency: number;
    /**
     * Chance that a particle will be spawned on each opportunity to spawn one.
     * 0 is 0%, 1 is 100%.
     */
    spawnChance: number;
    /**
     * Maximum number of particles to keep alive at a time. If this limit
     * is reached, no more particles will spawn until some have died.
     */
    maxParticles: number;
    /**
     * The amount of time in seconds to emit for before setting emit to false.
     * A value of -1 is an unlimited amount of time.
     */
    emitterLifetime: number;
    /**
     * Position at which to spawn particles, relative to the emitter's owner's origin.
     * For example, the flames of a rocket travelling right might have a spawnPos
     * of {x:-50, y:0}.
     * to spawn at the rear of the rocket.
     * To change this, use updateSpawnPos().
     */
    spawnPos: PIXI.Point;
    /**
     * Number of particles to spawn time that the frequency allows for particles to spawn.
     */
    particlesPerWave: number;
    /**
     * Rotation of the emitter or emitter's owner in degrees. This is added to
     * the calculated spawn angle.
     * To change this, use rotate().
     */
    protected rotation: number;
    /**
     * The world position of the emitter's owner, to add spawnPos to when
     * spawning particles. To change this, use updateOwnerPos().
     */
    protected ownerPos: PIXI.Point;
    /**
     * The origin + spawnPos in the previous update, so that the spawn position
     * can be interpolated to space out particles better.
     */
    protected _prevEmitterPos: PIXI.Point;
    /**
     * If _prevEmitterPos is valid, to prevent interpolation on the first update
     */
    protected _prevPosIsValid: boolean;
    /**
     * If either ownerPos or spawnPos has changed since the previous update.
     */
    protected _posChanged: boolean;
    /**
     * The container to add particles to.
     */
    protected _parent: PIXI.Container;
    /**
     * If particles should be added at the back of the display list instead of the front.
     */
    addAtBack: boolean;
    /**
     * The current number of active particles.
     */
    particleCount: number;
    /**
     * If particles should be emitted during update() calls. Setting this to false
     * stops new particles from being created, but allows existing ones to die out.
     */
    protected _emit: boolean;
    /**
     * The timer for when to spawn particles in seconds, where numbers less
     * than 0 mean that particles should be spawned.
     */
    protected _spawnTimer: number;
    /**
     * The life of the emitter in seconds.
     */
    protected _emitterLife: number;
    /**
     * The particles that are active and on the display list. This is the first particle in a
     * linked list.
     */
    protected _activeParticlesFirst: Particle;
    /**
     * The particles that are active and on the display list. This is the last particle in a
     * linked list.
     */
    protected _activeParticlesLast: Particle;
    /**
     * The particles that are not currently being used. This is the first particle in a
     * linked list.
     */
    protected _poolFirst: Particle;
    /**
     * The original config object that this emitter was initialized with.
     */
    protected _origConfig: any;
    /**
     * If the update function is called automatically from the shared ticker.
     * Setting this to false requires calling the update function manually.
     */
    protected _autoUpdate: boolean;
    /**
     * If the emitter should destroy itself when all particles have died out. This is set by
     * playOnceAndDestroy();
     */
    protected _destroyWhenComplete: boolean;
    /**
     * A callback for when all particles have died out. This is set by
     * playOnceAndDestroy() or playOnce();
     */
    protected _completeCallback: () => void;
    /**
     * @param particleParent The container to add the particles to.
     * @param particleImages A texture or array of textures to use
     *                       for the particles. Strings will be turned
     *                       into textures via Texture.fromImage().
     * @param config A configuration object containing settings for the emitter.
     * @param config.emit If config.emit is explicitly passed as false, the
     *                    Emitter will start disabled.
     * @param config.autoUpdate If config.autoUpdate is explicitly passed as
     *                          true, the Emitter will automatically call
     *                          update via the PIXI shared ticker.
     */
    constructor(particleParent: PIXI.Container, config: EmitterConfigV3);
    /**
     * Time between particle spawns in seconds. If this value is not a number greater than 0,
     * it will be set to 1 (particle per second) to prevent infinite loops.
     */
    get frequency(): number;
    set frequency(value: number);
    /**
     * The container to add particles to. Settings this will dump any active particles.
     */
    get parent(): PIXI.Container;
    set parent(value: PIXI.Container);
    /**
     * Sets up the emitter based on the config settings.
     * @param config A configuration object containing settings for the emitter.
     */
    init(config: EmitterConfigV3): void;
    /**
     * Gets the instantiated behavior of the specified type, if any.
     * @param type The behavior type to find.
     */
    getBehavior(type: string): IEmitterBehavior | null;
    /**
     * Fills the pool with the specified number of particles, so that they don't have to be instantiated later.
     * @param count The number of particles to create.
     */
    fillPool(count: number): void;
    /**
     * Recycles an individual particle. For internal use only.
     * @param particle The particle to recycle.
     * @param fromCleanup If this is being called to manually clean up all particles.
     * @internal
     */
    recycle(particle: Particle, fromCleanup?: boolean): void;
    /**
     * Sets the rotation of the emitter to a new value. This rotates the spawn position in addition
     * to particle direction.
     * @param newRot The new rotation, in degrees.
     */
    rotate(newRot: number): void;
    /**
     * Changes the spawn position of the emitter.
     * @param x The new x value of the spawn position for the emitter.
     * @param y The new y value of the spawn position for the emitter.
     */
    updateSpawnPos(x: number, y: number): void;
    /**
     * Changes the position of the emitter's owner. You should call this if you are adding
     * particles to the world container that your emitter's owner is moving around in.
     * @param x The new x value of the emitter's owner.
     * @param y The new y value of the emitter's owner.
     */
    updateOwnerPos(x: number, y: number): void;
    /**
     * Prevents emitter position interpolation in the next update.
     * This should be used if you made a major position change of your emitter's owner
     * that was not normal movement.
     */
    resetPositionTracking(): void;
    /**
     * If particles should be emitted during update() calls. Setting this to false
     * stops new particles from being created, but allows existing ones to die out.
     */
    get emit(): boolean;
    set emit(value: boolean);
    /**
     * If the update function is called automatically from the shared ticker.
     * Setting this to false requires calling the update function manually.
     */
    get autoUpdate(): boolean;
    set autoUpdate(value: boolean);
    /**
     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself
     * when particle emission is complete.
     * @param callback Callback for when emission is complete (all particles have died off)
     */
    playOnceAndDestroy(callback?: () => void): void;
    /**
     * Starts emitting particles and optionally calls a callback when particle emission is complete.
     * @param callback Callback for when emission is complete (all particles have died off)
     */
    playOnce(callback?: () => void): void;
    /**
     * Updates all particles spawned by this emitter and emits new ones.
     * @param delta Time elapsed since the previous frame, in __seconds__.
     */
    update(delta: number): void;
    /**
     * Emits a single wave of particles, using standard spawnChance & particlesPerWave settings. Does not affect
     * regular spawning through the frequency, and ignores the emit property.
     */
    emitNow(): void;
    /**
     * Kills all active particles immediately.
     */
    cleanup(): void;
    /**
     * Destroys the emitter and all of its particles.
     */
    destroy(): void;
  }
  /** Interface for a child of a LinkedListContainer (has the prev/next properties added) */
  export interface LinkedListChild extends PIXI.DisplayObject {
    nextChild: LinkedListChild | null;
    prevChild: LinkedListChild | null;
  }
  /**
   * A semi-experimental Container that uses a doubly linked list to manage children instead of an
   * array. This means that adding/removing children often is not the same performance hit that
   * it would to be continually pushing/splicing.
   * However, this is primarily intended to be used for heavy particle usage, and may not handle
   * edge cases well if used as a complete Container replacement.
   */
  export class LinkedListContainer extends PIXI.Container {
    private _firstChild;
    private _lastChild;
    private _childCount;
    get firstChild(): LinkedListChild;
    get lastChild(): LinkedListChild;
    get childCount(): number;
    addChild<T extends PIXI.DisplayObject[]>(...children: T): T[0];
    addChildAt<T extends PIXI.DisplayObject>(child: T, index: number): T;
    /**
     * Adds a child to the container to be rendered below another child.
     *
     * @param child The child to add
     * @param relative - The current child to add the new child relative to.
     * @return The child that was added.
     */
    addChildBelow<T extends PIXI.DisplayObject>(
      child: T,
      relative: PIXI.DisplayObject
    ): T;
    /**
     * Adds a child to the container to be rendered above another child.
     *
     * @param child The child to add
     * @param relative - The current child to add the new child relative to.
     * @return The child that was added.
     */
    addChildAbove<T extends PIXI.DisplayObject>(
      child: T,
      relative: PIXI.DisplayObject
    ): T;
    swapChildren(child: PIXI.DisplayObject, child2: PIXI.DisplayObject): void;
    getChildIndex(child: PIXI.DisplayObject): number;
    setChildIndex(child: PIXI.DisplayObject, index: number): void;
    removeChild<T extends PIXI.DisplayObject[]>(...children: T): T[0];
    getChildAt(index: number): PIXI.DisplayObject;
    removeChildAt(index: number): PIXI.DisplayObject;
    removeChildren(
      beginIndex?: number,
      endIndex?: number
    ): PIXI.DisplayObject[];
    /**
     * Updates the transform on all children of this container for rendering.
     * Copied from and overrides PixiJS v5 method (v4 method is identical)
     */
    updateTransform(): void;
    /**
     * Recalculates the bounds of the container.
     * Copied from and overrides PixiJS v5 method (v4 method is identical)
     */
    calculateBounds(): void;
    /**
     * Retrieves the local bounds of the displayObject as a rectangle object. Copied from and overrides PixiJS v5 method
     */
    getLocalBounds(
      rect?: PIXI.Rectangle,
      skipChildrenUpdate?: boolean
    ): PIXI.Rectangle;
    /**
     * Renders the object using the WebGL renderer. Copied from and overrides PixiJS v5 method
     */
    render(renderer: PIXI.Renderer): void;
    /**
     * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS v5 method
     */
    protected renderAdvanced(renderer: PIXI.Renderer): void;
    /**
     * Renders the object using the Canvas renderer. Copied from and overrides PixiJS Canvas mixin in V5 and V6.
     */
    renderCanvas(renderer: any): void;
  }
  /**
   * An individual particle image. You shouldn't have to deal with these.
   */
  export class Particle extends PIXI.Sprite implements PIXI.particles.LinkedListChild {
    /**
     * The emitter that controls this particle.
     */
    emitter: Emitter;
    /**
     * The maximum lifetime of this particle, in seconds.
     */
    maxLife: number;
    /**
     * The current age of the particle, in seconds.
     */
    age: number;
    /**
     * The current age of the particle as a normalized value between 0 and 1.
     */
    agePercent: number;
    /**
     * One divided by the max life of the particle, saved for slightly faster math.
     */
    oneOverLife: number;
    /**
     * Reference to the next particle in the list.
     */
    next: Particle;
    /**
     * Reference to the previous particle in the list.
     */
    prev: Particle;
    prevChild: LinkedListChild;
    nextChild: LinkedListChild;
    /**
     * Static per-particle configuration for behaviors to use. Is not cleared when recycling.
     */
    config: {
      [key: string]: any;
    };
    protected Sprite_destroy: typeof PIXI.Sprite.prototype.destroy;
    /**
     * @param emitter The emitter that controls this particle.
     */
    constructor(emitter: Emitter);
    /**
     * Initializes the particle for use, based on the properties that have to
     * have been set already on the particle.
     */
    init(maxLife: number): void;
    /**
     * Kills the particle, removing it from the display list
     * and telling the emitter to recycle it.
     */
    kill(): void;
    /**
     * Destroys the particle, removing references and preventing future use.
     */
    destroy(): void;
  }
  /**
   * Singly linked list container for keeping track of interpolated properties for particles.
   * Each Particle will have one of these for each interpolated property.
   */
  export class PropertyList<V> {
    /**
     * The first property node in the linked list.
     */
    first: PropertyNode<V>;
    /**
     * Calculates the correct value for the current interpolation value. This method is set in
     * the reset() method.
     * @param lerp The interpolation value from 0-1.
     * @return The interpolated value. Colors are converted to the hex value.
     */
    interpolate: (lerp: number) => number;
    /**
     * A custom easing method for this list.
     * @param lerp The interpolation value from 0-1.
     * @return The eased value, also from 0-1.
     */
    ease: SimpleEase;
    /**
     * If this list manages colors, which requires a different method for interpolation.
     */
    private isColor;
    /**
     * @param isColor If this list handles color values
     */
    constructor(isColor?: boolean);
    /**
     * Resets the list for use.
     * @param first The first node in the list.
     * @param first.isStepped If the values should be stepped instead of interpolated linearly.
     */
    reset(first: PropertyNode<V>): void;
  }
  namespace behaviors {
/**
 * A Movement behavior that handles movement by applying a constant acceleration to all particles.
 *
 * Example configuration:
 * ```javascript
 * {
 *     "type": "moveAcceleration",
 *     "config": {
 *          "accel": {
 *               "x": 0,
 *               "y": 2000
 *          },
 *          "minStart": 600,
 *          "maxStart": 600,
 *          "rotate": true
 *     }
 *}
 * ```
 */
export class AccelerationBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private minStart;
    private maxStart;
    private accel;
    private rotate;
    private maxSpeed;
    constructor(config: {
        /**
         * Minimum speed when initializing the particle, in world units/second.
         */
        minStart: number;
        /**
         * Maximum speed when initializing the particle. in world units/second.
         */
        maxStart: number;
        /**
         * Constant acceleration, in the coordinate space of the particle parent, in world units/second.
         */
        accel: {
            x: number;
            y: number;
        };
        /**
         * Rotate the particle with its direction of movement.
         * While initial movement direction reacts to rotation settings, this overrides any dynamic rotation.
         * Defaults to false.
         */
        rotate?: boolean;
        /**
         * Maximum linear speed. 0 is unlimited. Defaults to 0.
         */
        maxSpeed?: number;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle, deltaSec: number): void;
}

/**
 * An Alpha behavior that applies an interpolated or stepped list of values to the particle's opacity.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'alpha',
 *     config: {
 *         alpha: {
 *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}]
 *         },
 *     }
 * }
 * ```
 */
export class AlphaBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private list;
    constructor(config: {
        /**
         * Transparency of the particles from 0 (transparent) to 1 (opaque)
         */
        alpha: ValueList<number>;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle): void;
}
/**
 * An Alpha behavior that applies a static value to the particle's opacity at particle initialization.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'alphaStatic',
 *     config: {
 *         alpha: 0.75,
 *     }
 * }
 * ```
 */
export class StaticAlphaBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private value;
    constructor(config: {
        /**
         * Transparency of the particles from 0 (transparent) to 1 (opaque)
         */
        alpha: number;
    });
    initParticles(first: Particle): void;
}

/**
 * The format of a single animation to be used on a particle.
 */
export interface AnimatedParticleArt {
    /**
     * Framerate for the animation (in frames per second). A value of -1 will tie the framerate to
     * the particle's lifetime so that the animation lasts exactly as long as the particle.
     */
    framerate: -1 | number;
    /**
     * If the animation should loop. Defaults to false.
     */
    loop?: boolean;
    /**
     * A list of textures or frame descriptions for duplicated frames.
     * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.
     * Example of a texture repeated for 5 frames, followed by a second texture for one frame:
     * ```javascript
     * [{texture: 'myFirstTex', count: 5}, 'mySecondTex']
     * ```
     */
    textures: (string | PIXI.Texture | {
        texture: string | PIXI.Texture;
        count: number;
    })[];
}
/**
 * Internal data format for playback.
 */
export interface ParsedAnimatedParticleArt {
    textures: PIXI.Texture[];
    duration: number;
    framerate: number;
    loop: boolean;
}
/**
 * A Texture behavior that picks a random animation for each particle to play.
 * See {@link AnimatedParticleArt} for detailed configuration info.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'animatedRandom',
 *     config: {
 *         anims: [
 *              {
 *                  framerate: 25,
 *                  loop: true,
 *                  textures: ['frame1', 'frame2', 'frame3']
 *              },
 *              {
 *                  framerate: 25,
 *                  loop: true,
 *                  textures: ['frame3', 'frame2', 'frame1']
 *              }
 *         ],
 *     }
 * }
 * ```
 */
export class RandomAnimatedTextureBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private anims;
    constructor(config: {
        /**
         * Animation configuration to use for each particle, randomly chosen from the list.
         */
        anims: AnimatedParticleArt[];
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle, deltaSec: number): void;
}
/**
 * A Texture behavior that uses a single animation for each particle to play.
 * See {@link AnimatedParticleArt} for detailed configuration info.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'animatedSingle',
 *     config: {
 *         anim: {
 *              framerate: 25,
 *              loop: true,
 *              textures: ['frame1', 'frame2', 'frame3']
 *         }
 *     }
 * }
 * ```
 */
export class SingleAnimatedTextureBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private anim;
    constructor(config: {
        /**
         * Animation configuration to use for each particle.
         */
        anim: AnimatedParticleArt;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle, deltaSec: number): void;
}

/**
 * All behaviors instances must implement this interface, and the class must match the
 * {@link IEmitterBehaviorClass} interface. All behaviors must have an order property and
 * `initParticles` method. Implementing the `updateParticle` or `recycleParticle` methods is optional.
 */
export interface IEmitterBehavior {
    /**
     * Order in which the behavior will be handled. Lower numbers are handled earlier, with an order of 0 getting
     * special treatment before the Emitter's transformation is applied.
     */
    order: number;
    /**
     * Called to initialize a wave of particles, with a reference to the first particle in the linked list.
     * @param first The first (maybe only) particle in a newly spawned wave of particles.
     */
    initParticles(first: Particle): void;
    /**
     * Updates a single particle for a given period of time elapsed. Return `true` to recycle the particle.
     * @param particle The particle to update.
     * @param deltaSec The time to advance the particle by in seconds.
     */
    updateParticle?(particle: Particle, deltaSec: number): void | boolean;
    /**
     * A hook for when a particle is recycled.
     * @param particle The particle that was just recycled.
     * @param natural `true` if the reycling was due to natural lifecycle, `false` if it was due to emitter cleanup.
     */
    recycleParticle?(particle: Particle, natural: boolean): void;
}
/**
 * All behavior classes must match this interface. The instances need to implement the {@link IEmitterBehavior} interface.
 */
export interface IEmitterBehaviorClass {
    /**
     * The unique type name that the behavior is registered under.
     */
    type: string;
    /**
     * Configuration data for an editor to display this behavior. Does not need to exist in production code.
     */
    editorConfig?: editor.BehaviorEditorConfig;
    /**
     * The behavior constructor itself.
     * @param config The config for the behavior, which should match its defined specifications.
     */
    new (config: any): IEmitterBehavior;
}
/**
 * Standard behavior order values, specifying when/how they are used. Other numeric values can be used,
 * but only the Spawn value will be handled in a special way. All other values will be sorted numerically.
 * Behaviors with the same value will not be given any specific sort order, as they are assumed to not
 * interfere with each other.
 */
export enum BehaviorOrder {
    /**
     * Spawn - initial placement and/or rotation. This happens before rotation/translation due to
     * emitter rotation/position is applied.
     */
    Spawn = 0,
    /**
     * Normal priority, for things that don't matter when they are applied.
     */
    Normal = 2,
    /**
     * Delayed priority, for things that need to read other values in order to act correctly.
     */
    Late = 5
}

/**
 * A Blend Mode behavior that applies a blend mode value to the particle at initialization.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'blendMode',
 *     config: {
 *         blendMode: 'multiply',
 *     }
 * }
 * ```
 */
export class BlendModeBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private value;
    constructor(config: {
        /**
         * Blend mode of all particles. This value is a key from
         * [PixiJs's BLEND_MODE enum](https://pixijs.download/release/docs/PIXI.html#BLEND_MODES).
         */
        blendMode: string;
    });
    initParticles(first: Particle): void;
}

/**
 * A Spawn behavior that sends particles out from a single point or ring, and is capable of evenly spacing
 * the particle's starting angles.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'spawnBurst',
 *     config: {
 *          spacing: 90,
 *          start: 0,
 *          distance: 40,
 *     }
 * }
 * ```
 */
export class BurstSpawnBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private spacing;
    private start;
    private distance;
    constructor(config: {
        /**
         * Description: Spacing between each particle spawned in a wave, in degrees.
         */
        spacing: number;
        /**
         * Description: Angle to start placing particles at, in degrees. 0 is facing right, 90 is facing upwards.
         */
        start: number;
        /**
         * Description: Distance from the emitter to spawn particles, forming a ring/arc.
         */
        distance: number;
    });
    initParticles(first: Particle): void;
}

/**
 * A Color behavior that applies an interpolated or stepped list of values to the particle's tint property.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'color',
 *     config: {
 *         color: {
 *              list: [{value: '#ff0000' time: 0}, {value: '#00ff00', time: 0.5}, {value: '#0000ff', time: 1}]
 *         },
 *     }
 * }
 * ```
 */
export class ColorBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private list;
    constructor(config: {
        /**
         * Color of the particles as 6 digit hex codes.
         */
        color: ValueList<string>;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle): void;
}
/**
 * A Color behavior that applies a single color to the particle's tint property at initialization.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'colorStatic',
 *     config: {
 *         color: '#ffff00',
 *     }
 * }
 * ```
 */
export class StaticColorBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private value;
    constructor(config: {
        /**
         * Color of the particles as 6 digit hex codes.
         */
        color: string;
    });
    initParticles(first: Particle): void;
}

/**
 * A Texture behavior that assigns a texture to each particle from its list, in order, before looping around to the first
 * texture again. String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'textureOrdered',
 *     config: {
 *         textures: ["myTex1Id", "myTex2Id", "myTex3Id", "myTex4Id"],
 *     }
 * }
 * ```
 */
export class OrderedTextureBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private textures;
    private index;
    constructor(config: {
        /**
         * Images to use for each particle, used in order before looping around
         */
        textures: PIXI.Texture[];
    });
    initParticles(first: Particle): void;
}

/**
 * A particle that follows a path defined by an algebraic expression, e.g. "sin(x)" or
 * "5x + 3".
 * To use this class, the behavior config must have a "path" string or function.
 *
 * A string should have "x" in it to represent movement (from the
 * speed settings of the behavior). It may have numbers, parentheses, the four basic
 * operations, and any Math functions or properties (without the preceding "Math.").
 * The overall movement of the particle and the expression value become x and y positions for
 * the particle, respectively. The final position is rotated by the spawn rotation/angle of
 * the particle.
 *
 * A function merely needs to accept the "x" argument and output the a corresponding "y" value.
 *
 * Some example paths:
 *
 * * `"sin(x/10) * 20"` A sine wave path.
 * * `"cos(x/100) * 30"` Particles curve counterclockwise (for medium speed/low lifetime particles)
 * * `"pow(x/10, 2) / 2"` Particles curve clockwise (remember, +y is down).
 * * `(x) => Math.floor(x) * 3` Supplying an existing function should look like this
 *
 * Example configuration:
 * ```javascript
 * {
 *     "type": "movePath",
 *     "config": {
 *          "path": "round(sin(x) * 2",
 *          "speed": {
 *              "list": [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],
 *          },
 *          "minMult": 0.8
 *     }
 *}
 */
export class PathBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    /**
     * The function representing the path the particle should take.
     */
    private path;
    private list;
    private minMult;
    constructor(config: {
        /**
         * Algebraic expression describing the movement of the particle.
         */
        path: string | ((x: number) => number);
        /**
         * Speed of the particles in world units/second. This affects the x value in the path.
         * Unlike normal speed movement, this can have negative values.
         */
        speed: ValueList<number>;
        /**
         * A value between minimum speed multipler and 1 is randomly generated and multiplied
         * with each speed value to generate the actual speed for each particle.
         */
        minMult: number;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle, deltaSec: number): void;
}

/**
 * A Spawn behavior that sends particles out from a single point at the emitter's position.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'spawnPoint',
 *     config: {}
 * }
 * ```
 */
export class PointSpawnBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    initParticles(_first: Particle): void;
}

/**
 * A Texture behavior that assigns a random texture to each particle from its list.
 * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'textureRandom',
 *     config: {
 *         textures: ["myTex1Id", "myTex2Id", "myTex3Id", "myTex4Id"],
 *     }
 * }
 * ```
 */
export class RandomTextureBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private textures;
    constructor(config: {
        /**
         * Images to use for each particle, randomly chosen from the list.
         */
        textures: (PIXI.Texture | string)[];
    });
    initParticles(first: Particle): void;
}

/**
 * A Rotation behavior that handles starting rotation, rotation speed, and rotational acceleration.
 *
 * Example configuration:
 * ```javascript
 * {
 *     "type": "rotation",
 *     "config": {
 *          "minStart": 0,
 *          "maxStart": 180,
 *          "minSpeed": 30,
 *          "maxSpeed": 45,
 *          "accel": 20
 *     }
 *}
 * ```
 */
export class RotationBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private minStart;
    private maxStart;
    private minSpeed;
    private maxSpeed;
    private accel;
    constructor(config: {
        /**
         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.
         */
        minStart: number;
        /**
         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.
         */
        maxStart: number;
        /**
         * Minimum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.
         */
        minSpeed: number;
        /**
         * Maximum rotation speed of the particles, in degrees/second. Positive is counter-clockwise.
         */
        maxSpeed: number;
        /**
         * Constant rotational acceleration of the particles, in degrees/second/second.
         */
        accel: number;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle, deltaSec: number): void;
}
/**
 * A Rotation behavior that handles starting rotation.
 *
 * Example configuration:
 * ```javascript
 * {
 *     "type": "rotationStatic",
 *     "config": {
 *          "min": 0,
 *          "max": 180,
 *     }
 *}
 * ```
 */
export class StaticRotationBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private min;
    private max;
    constructor(config: {
        /**
         * Minimum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.
         */
        min: number;
        /**
         * Maximum starting rotation of the particles, in degrees. 0 is facing right, 90 is upwards.
         */
        max: number;
    });
    initParticles(first: Particle): void;
}
/**
 * A Rotation behavior that blocks all rotation caused by spawn settings,
 * by resetting it to the specified rotation (or 0).
 *
 * Example configuration:
 * ```javascript
 * {
 *     "type": "noRotation",
 *     "config": {
 *          "rotation": 0
 *     }
 *}
 * ```
 */
export class NoRotationBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: number;
    private rotation;
    constructor(config: {
        /**
         * Locked rotation of the particles, in degrees. 0 is facing right, 90 is upwards.
         */
        rotation?: number;
    });
    initParticles(first: Particle): void;
}

/**
 * A Scale behavior that applies an interpolated or stepped list of values to the particle's x & y scale.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'scale',
 *     config: {
 *          scale: {
 *              list: [{value: 0, time: 0}, {value: 1, time: 0.25}, {value: 0, time: 1}],
 *              isStepped: true
 *          },
 *          minMult: 0.5
 *     }
 * }
 * ```
 */
export class ScaleBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private list;
    private minMult;
    constructor(config: {
        /**
         * Scale of the particles, with a minimum value of 0
         */
        scale: ValueList<number>;
        /**
         * A value between minimum scale multipler and 1 is randomly
         * generated and multiplied with each scale value to provide the actual scale for each particle.
         */
        minMult: number;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle): void;
}
/**
 * A Scale behavior that applies a randomly picked value to the particle's x & y scale at initialization.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'scaleStatic',
 *     config: {
 *         min: 0.25,
 *         max: 0.75,
 *     }
 * }
 * ```
 */
export class StaticScaleBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private min;
    private max;
    constructor(config: {
        /**
         * Minimum scale of the particles, with a minimum value of 0
         */
        min: number;
        /**
         * Maximum scale of the particles, with a minimum value of 0
         */
        max: number;
    });
    initParticles(first: Particle): void;
}

/**
 * A Spawn behavior that places (and optionally rotates) particles according to a
 * specified shape. Additional shapes can be registered with {@link registerShape | SpawnShape.registerShape()}.
 * Additional shapes must implement the {@link SpawnShape} interface, and their class must match the
 * {@link SpawnShapeClass} interface.
 * Shapes included by default are:
 * * {@link Rectangle}
 * * {@link Torus}
 * * {@link PolygonalChain}
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'spawnShape',
 *     config: {
 *          type: 'rect',
 *          data: {
 *              x: 0,
 *              y: 0,
 *              width: 20,
 *              height: 300,
 *          }
 *     }
 * }
 * ```
 */
export class ShapeSpawnBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    /**
     * Dictionary of all registered shape classes.
     */
    private static shapes;
    /**
     * Registers a shape to be used by the ShapeSpawn behavior.
     * @param constructor The shape class constructor to use, with a static `type` property to reference it by.
     * @param typeOverride An optional type override, primarily for registering a shape under multiple names.
     */
    static registerShape(constructor: shapes.SpawnShapeClass, typeOverride?: string): void;
    order: BehaviorOrder;
    private shape;
    constructor(config: {
        /**
         * Type of the shape to spawn
         */
        type: string;
        /**
         * Configuration data for the spawn shape.
         */
        data: any;
    });
    initParticles(first: Particle): void;
}
/**
 * A Textuure behavior that assigns a single texture to each particle.
 * String values will be converted to textures with {@link ParticleUtils.GetTextureFromString}.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'textureSingle',
 *     config: {
 *         texture: Texture.from('myTexId'),
 *     }
 * }
 * ```
 */
export class SingleTextureBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private texture;
    constructor(config: {
        /**
         * Image to use for each particle.
         */
        texture: PIXI.Texture | string;
    });
    initParticles(first: Particle): void;
}
/**
 * A Movement behavior that uses an interpolated or stepped list of values for a particles speed at any given moment.
 * Movement direction is controlled by the particle's starting rotation.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'moveSpeed',
 *     config: {
 *          speed: {
 *              list: [{value: 10, time: 0}, {value: 100, time: 0.25}, {value: 0, time: 1}],
 *          },
 *          minMult: 0.8
 *     }
 * }
 * ```
 */
export class SpeedBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private list;
    private minMult;
    constructor(config: {
        /**
         * Speed of the particles in world units/second, with a minimum value of 0
         */
        speed: ValueList<number>;
        /**
         * A value between minimum speed multipler and 1 is randomly
         * generated and multiplied with each speed value to generate the actual speed for each particle.
         */
        minMult: number;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle, deltaSec: number): void;
}
/**
 * A Movement behavior that uses a randomly picked constant speed throughout a particle's lifetime.
 * Movement direction is controlled by the particle's starting rotation.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'moveSpeedStatic',
 *     config: {
 *          min: 100,
 *          max: 150
 *     }
 * }
 * ```
 */
export class StaticSpeedBehavior implements IEmitterBehavior {
    static type: string;
    static editorConfig: editor.BehaviorEditorConfig;
    order: BehaviorOrder;
    private min;
    private max;
    constructor(config: {
        /**
         * Minimum speed when initializing the particle.
         */
        min: number;
        /**
         * Maximum speed when initializing the particle.
         */
        max: number;
    });
    initParticles(first: Particle): void;
    updateParticle(particle: Particle, deltaSec: number): void;
}
namespace shapes {
/**
 * Data structure for internal parsed data in PolygonalChain spawn shapes.
 */
export interface Segment {
    p1: PIXI.IPointData;
    p2: PIXI.IPointData;
    l: number;
}
/**
 * A spawn shape that picks a random position along a series of line segments. If those
 * line segments form a polygon, particles will only be placed on the perimeter of that polygon.
 *
 * Example config:
 * ```javascript
 * {
 *      type: 'polygonalChain',
 *      data: [
 *          [{x: 0, y: 0}, {x: 10, y: 10}, {x: 20, y: 0}],
 *          [{x: 0, y, -10}, {x: 10, y: 0}, {x: 20, y: -10}]
 *      ]
 * }
 * ```
 */
export class PolygonalChain implements SpawnShape {
    static type: string;
    static editorConfig: editor.ListProperty;
    /**
     * List of segment objects in the chain.
     */
    private segments;
    /**
     * Total length of all segments of the chain.
     */
    private totalLength;
    /**
     * Total length of segments up to and including the segment of the same index.
     * Used for weighted random selection of segment.
     */
    private countingLengths;
    /**
     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.
     */
    constructor(data: PIXI.IPointData[] | PIXI.IPointData[][]);
    /**
     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.
     */
    private init;
    /**
     * Gets a random point in the chain.
     * @param out The point to store the selected position in.
     */
    getRandPos(out: PIXI.IPointData): void;
}

/**
 * A SpawnShape that randomly picks locations inside a rectangle.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'rect',
 *     data: {
 *          x: 0,
 *          y: 0,
 *          w: 10,
 *          h: 100
 *     }
 * }
 * ```
 */
export class Rectangle implements SpawnShape {
    static type: string;
    static editorConfig: editor.ObjectProperty;
    /**
     * X (left) position of the rectangle.
     */
    x: number;
    /**
     * Y (top) position of the rectangle.
     */
    y: number;
    /**
     * Width of the rectangle.
     */
    w: number;
    /**
     * Height of the rectangle.
     */
    h: number;
    constructor(config: {
        /**
         * X (left) position of the rectangle.
         */
        x: number;
        /**
         * Y (top) position of the rectangle.
         */
        y: number;
        /**
         * Width of the rectangle.
         */
        w: number;
        /**
         * Height of the rectangle.
         */
        h: number;
    });
    getRandPos(particle: Particle): void;
}

/**
 * Any shape capable of generating a random position for the {@link ShapeSpawnBehavior | shape spawn behavior}.
 */
export interface SpawnShape {
    /**
     * Assign a random position to the given particle.
     * Rotation may optionally be applied; assigning any other properties, while allowed, would be improper.
     */
    getRandPos(particle: Particle): void;
}
/**
 * Class definition/static properties for a shape capable of generating a random
 * position for the {@link ShapeSpawnBehavior | shape spawn behavior}.
 */
export interface SpawnShapeClass {
    /**
     * Type that the shape is registered under.
     */
    type: string;
    /**
     * Configuration for an editor to display. This does not need to exist in production code.
     */
    editorConfig?: editor.ObjectProperty | editor.ListProperty;
    /**
     * The shape constructor itself.
     * @param config The config for the shape, which should match its defined specifications.
     */
    new (config: any): SpawnShape;
}

/**
 * A class for spawning particles in a circle or ring.
 * Can optionally apply rotation to particles so that they are aimed away from the center of the circle.
 *
 * Example config:
 * ```javascript
 * {
 *     type: 'torus',
 *     data: {
 *          radius: 30,
 *          x: 0,
 *          y: 0,
 *          innerRadius: 10,
 *          rotation: true
 *     }
 * }
 * ```
 */
export class Torus implements SpawnShape {
    static type: string;
    static editorConfig: editor.ObjectProperty;
    /**
     * X position of the center of the shape.
     */
    x: number;
    /**
     * Y position of the center of the shape.
     */
    y: number;
    /**
     * Radius of circle, or outer radius of a ring.
     */
    radius: number;
    /**
     * Inner radius of a ring. Use 0 to have a circle.
     */
    innerRadius: number;
    /**
     * If rotation should be applied to particles.
     */
    rotation: boolean;
    constructor(config: {
        /**
         * Radius of circle, or outer radius of a ring. Note that this uses the full name of 'radius',
         * where earlier versions of the library may have used 'r'.
         */
        radius: number;
        /**
         * X position of the center of the shape.
         */
        x: number;
        /**
         * Y position of the center of the shape.
         */
        y: number;
        /**
         * Inner radius of a ring. Omit, or use 0, to have a circle.
         */
        innerRadius?: number;
        /**
         * If rotation should be applied to particles, pointing them away from the center of the torus.
         * Defaults to false.
         */
        affectRotation?: boolean;
    });
    getRandPos(particle: Particle): void;
}
}
namespace editor {
  export interface NumberProperty {
    type: 'number';
    name: string;
    title: string;
    description: string;
    default: number;
    min?: number;
    max?: number;
}
export interface ColorProperty {
    type: 'color';
    name: string;
    title: string;
    description: string;
    default: string;
}
export interface BooleanProperty {
    type: 'boolean';
    name: string;
    title: string;
    description: string;
    default: boolean;
}
export interface TextProperty {
    type: 'text';
    name: string;
    title: string;
    description: string;
    default: string;
}
export interface PointProperty {
    type: 'point';
    name: string;
    title: string;
    description: string;
    default: {
        x: number;
        y: number;
    };
}
export interface NumberListProperty {
    type: 'numberList';
    name: string;
    title: string;
    description: string;
    default: number;
    min?: number;
    max?: number;
}
export interface ColorListProperty {
    type: 'colorList';
    name: string;
    title: string;
    description: string;
    default: string;
}
export interface ImageProperty {
    type: 'image';
    name: string;
    title: string;
    description: string;
}
export interface ListProperty {
    type: 'list';
    name: string;
    title: string;
    description: string;
    entryType: Property;
}
export interface ObjectProperty {
    type: 'object';
    name: string;
    title: string;
    description: string;
    props: Property[];
}
export interface SelectProperty {
    type: 'select';
    name: string;
    title: string;
    description: string;
    options: {
        label: string;
        value: string;
    }[];
    default: string;
}
export interface SelectSubConfigProperty {
    type: 'subconfig';
    /** Name of property where the type of the config is stored */
    name: string;
    title: string;
    description: string;
    dictionaryProp: string;
    /** Name of property in which the config should be stored */
    configName: string;
}
export type Property = NumberProperty | ColorProperty | BooleanProperty | TextProperty | PointProperty | NumberListProperty | ColorListProperty | ImageProperty | ListProperty | ObjectProperty | SelectProperty | SelectSubConfigProperty;
export interface BehaviorEditorConfig {
    category: 'art' | 'color' | 'alpha' | 'scale' | 'movement' | 'rotation' | 'blend' | 'spawn' | 'other';
    title: string;
    props: Property[];
}
}
  }
}
}