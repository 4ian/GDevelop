{"version":3,"file":"graphics-extras.min.js","sources":["../src/drawChamferRect.ts","../src/drawFilletRect.ts","../src/drawRegularPolygon.ts","../src/drawRoundedPolygon.ts","../src/drawRoundedShape.ts","../src/drawStar.ts","../src/drawTorus.ts","../src/index.ts"],"sourcesContent":["import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw Rectangle with chamfer corners. These are angled corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawChamferRect\n * @param this\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} chamfer - non-zero real number, size of corner cutout\n * @returns {PIXI.Graphics} Returns self.\n */\nexport function drawChamferRect(this: Graphics,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    chamfer: number): Graphics\n{\n    if (chamfer <= 0)\n    {\n        return this.drawRect(x, y, width, height);\n    }\n\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n        x + inset, y,\n        right - inset, y,\n        right, y + inset,\n        right, bottom - inset,\n        right - inset, bottom,\n        x + inset, bottom,\n        x, bottom - inset,\n        x, y + inset,\n    ];\n\n    // Remove overlapping points\n    for (let i = points.length - 1; i >= 2; i -= 2)\n    {\n        if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n        {\n            points.splice(i - 1, 2);\n        }\n    }\n\n    return this.drawPolygon(points);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw Rectangle with fillet corners. This is much like rounded rectangle\n * however it support negative numbers as well for the corner radius.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawFilletRect\n * @param this\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} fillet - accept negative or positive values\n * @returns {PIXI.Graphics} Returns self.\n */\nexport function drawFilletRect(this: Graphics,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    fillet: number): Graphics\n{\n    if (fillet === 0)\n    {\n        return this.drawRect(x, y, width, height);\n    }\n\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n\n    return this\n        .moveTo(x, y + size)\n        .arcTo(x + dir, y + dir, x + size, y, size)\n        .lineTo(right - size, y)\n        .arcTo(right - dir, y + dir, right, y + size, size)\n        .lineTo(right, bottom - size)\n        .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n        .lineTo(x + size, bottom)\n        .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n        .closePath();\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a regular polygon where all sides are the same length.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRegularPolygon\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} rotation - Starting rotation values in radians..\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawRegularPolygon(this: Graphics,\n    x: number,\n    y: number,\n    radius: number,\n    sides: number,\n    rotation = 0): Graphics\n{\n    sides = Math.max(sides | 0, 3);\n    const startAngle = (-1 * Math.PI / 2) + rotation;\n    const delta = (Math.PI * 2) / sides;\n    const polygon = [];\n\n    for (let i = 0; i < sides; i++)\n    {\n        const angle = (i * delta) + startAngle;\n\n        polygon.push(\n            x + (radius * Math.cos(angle)),\n            y + (radius * Math.sin(angle))\n        );\n    }\n\n    return this.drawPolygon(polygon);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a regular polygon with rounded corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRoundedPolygon\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} corner - Corner size in pixels.\n * @param {number} rotation - Starting rotation values in radians..\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawRoundedPolygon(this: Graphics,\n    x: number,\n    y: number,\n    radius: number,\n    sides: number,\n    corner: number,\n    rotation = 0): Graphics\n{\n    sides = Math.max((sides | 0), 3);\n\n    if (corner <= 0)\n    {\n        return this.drawRegularPolygon(x, y, radius, sides, rotation);\n    }\n\n    const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n    corner = Math.min(corner, sideLength);\n\n    const startAngle = (-1 * Math.PI / 2) + rotation;\n    const delta = (Math.PI * 2) / sides;\n    const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n    for (let i = 0; i < sides; i++)\n    {\n        const angle = (i * delta) + startAngle;\n        const x0 = x + (radius * Math.cos(angle));\n        const y0 = y + (radius * Math.sin(angle));\n        const a1 = angle + (Math.PI) + internalAngle;\n        const a2 = angle - (Math.PI) - internalAngle;\n        const x1 = x0 + (corner * Math.cos(a1));\n        const y1 = y0 + (corner * Math.sin(a1));\n        const x3 = x0 + (corner * Math.cos(a2));\n        const y3 = y0 + (corner * Math.sin(a2));\n\n        if (i === 0)\n        {\n            this.moveTo(x1, y1);\n        }\n        else\n        {\n            this.lineTo(x1, y1);\n        }\n        this.quadraticCurveTo(x0, y0, x3, y3);\n    }\n\n    return this.closePath();\n}\n","import type { IPointData } from '@pixi/core';\nimport type { Graphics } from '@pixi/graphics';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param {PIXI.Graphics} g - Graphics to be drawn on.\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n */\nfunction roundedShapeArc(\n    g: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number\n): void\n{\n    const vecFrom = (p: IPointData, pp: IPointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: IPointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param {PIXI.Graphics} g - Graphics to be drawn on.\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n */\nfunction roundedShapeQuadraticCurve(\n    g: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number\n): void\n{\n    const distance = (p1: IPointData, p2: IPointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: IPointData, p2: IPointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y);\n    }\n}\n\n/**\n * Draw a Shape with rounded corners.\n * Supports custom radius for each point.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRoundedShape\n * @param this\n * @param {(IPointData & { radius?: number })[]} points - Corners of the shape to draw. Minimum length is 3.\n * @param {number} radius - Corners default radius.\n * @param {boolean} useQuadraticCurve - If true, rounded corners will be drawn using quadraticCurve instead of arc.\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls.\n */\nexport function drawRoundedShape(\n    this: Graphics,\n    points: (IPointData & { radius?: number })[],\n    radius: number,\n    useQuadraticCurve?: boolean\n): Graphics\n{\n    if (points.length < 3)\n    {\n        return this;\n    }\n\n    if (useQuadraticCurve)\n    {\n        roundedShapeQuadraticCurve(this, points, radius);\n    }\n    else\n    {\n        roundedShapeArc(this, points, radius);\n    }\n\n    return this.closePath();\n}\n","import { PI_2, Polygon } from '@pixi/core';\n\nimport type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a star shape with an arbitrary number of points.\n * @ignore\n */\nclass Star extends Polygon\n{\n    /**\n     * @param x - Center X position of the star\n     * @param y - Center Y position of the star\n     * @param points - The number of points of the star, must be > 1\n     * @param radius - The outer radius of the star\n     * @param innerRadius - The inner radius between points, default half `radius`\n     * @param rotation - The rotation of the star in radians, where 0 is vertical\n     */\n    constructor(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawStar\n * @param this\n * @param x - Center X position of the star\n * @param y - Center Y position of the star\n * @param points - The number of points of the star, must be > 1\n * @param radius - The outer radius of the star\n * @param innerRadius - The inner radius between points, default half `radius`\n * @param rotation - The rotation of the star in radians, where 0 is vertical\n * @returns - This Graphics object. Good for chaining method calls\n */\nexport function drawStar(this: Graphics,\n    x: number,\n    y: number,\n    points: number,\n    radius: number,\n    innerRadius: number,\n    rotation = 0): Graphics\n{\n    return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation) as Polygon);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a torus shape, like a donut. Can be used for something like a circle loader.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawTorus\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} innerRadius - Inner circle radius\n * @param {number} outerRadius - Outer circle radius\n * @param {number} [startArc=0] - Where to begin sweep, in radians, 0.0 = to the right\n * @param {number} [endArc=Math.PI*2] - Where to end sweep, in radians\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawTorus(this: Graphics,\n    x: number,\n    y: number,\n    innerRadius: number,\n    outerRadius: number,\n    startArc = 0,\n    endArc: number = Math.PI * 2): Graphics\n{\n    if (Math.abs(endArc - startArc) >= Math.PI * 2)\n    {\n        return this\n            .drawCircle(x, y, outerRadius)\n            .beginHole()\n            .drawCircle(x, y, innerRadius)\n            .endHole();\n    }\n\n    this.finishPoly();\n    this\n        .arc(x, y, innerRadius, endArc, startArc, true)\n        .arc(x, y, outerRadius, startArc, endArc, false)\n        .finishPoly();\n\n    return this;\n}\n","/// <reference path=\"../global.d.ts\" />\nimport { Graphics } from '@pixi/graphics';\nimport { drawChamferRect } from './drawChamferRect';\nimport { drawFilletRect } from './drawFilletRect';\nimport { drawRegularPolygon } from './drawRegularPolygon';\nimport { drawRoundedPolygon } from './drawRoundedPolygon';\nimport { drawRoundedShape } from './drawRoundedShape';\nimport { drawStar } from './drawStar';\nimport { drawTorus } from './drawTorus';\n\nexport interface IGraphicsExtras\n{\n    drawTorus: typeof drawTorus;\n    drawChamferRect: typeof drawChamferRect;\n    drawFilletRect: typeof drawFilletRect;\n    drawRegularPolygon: typeof drawRegularPolygon;\n    drawRoundedPolygon: typeof drawRoundedPolygon;\n    drawRoundedShape: typeof drawRoundedShape;\n    drawStar: typeof drawStar;\n}\n\n// Assign extras to Graphics\nObject.defineProperties(Graphics.prototype, {\n    drawTorus: { value: drawTorus },\n    drawChamferRect: { value: drawChamferRect },\n    drawFilletRect: { value: drawFilletRect },\n    drawRegularPolygon: { value: drawRegularPolygon },\n    drawRoundedPolygon: { value: drawRoundedPolygon },\n    drawRoundedShape: { value: drawRoundedShape },\n    drawStar: { value: drawStar },\n});\n"],"names":["drawChamferRect","x","y","width","height","chamfer","inset","right","bottom","points","i","drawFilletRect","fillet","maxFillet","dir","size","drawRegularPolygon","radius","sides","rotation","startAngle","delta","polygon","angle","drawRoundedPolygon","corner","sideLength","internalAngle","x0","y0","a1","a2","x1","y1","x3","y3","roundedShapeArc","g","_a","vecFrom","p","pp","len","nx","ny","sharpCorner","p1","p2","pRadius","p3","v1","v2","radDirection","drawDirection","halfAngle","cRadius","lenOut","cX","cY","endAngle","roundedShapeQuadraticCurve","distance","pointLerp","t","numPoints","thisPoint","lastPoint","nextPoint","lastEdgeLength","start","lastOffsetDistance","nextEdgeLength","end","nextOffsetDistance","drawRoundedShape","useQuadraticCurve","Star","Polygon","innerRadius","PI_2","r","drawStar","drawTorus","outerRadius","startArc","endArc","Graphics"],"mappings":"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"}