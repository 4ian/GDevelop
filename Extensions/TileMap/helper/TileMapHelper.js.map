{"version":3,"file":"TileMapHelper.js","mappings":"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","sources":["webpack://TileMapHelper/webpack/universalModuleDefinition","webpack://TileMapHelper/./PixiTileMapHelper.ts","webpack://TileMapHelper/./ResourceCache.ts","webpack://TileMapHelper/./TileMapManager.ts","webpack://TileMapHelper/./TileMapModel.ts","webpack://TileMapHelper/./TileTextureCache.ts","webpack://TileMapHelper/./index.ts","webpack://TileMapHelper/./tiled/TiledLoaderHelper.ts","webpack://TileMapHelper/./tiled/TiledTileMapLoader.ts","webpack://TileMapHelper/webpack/bootstrap","webpack://TileMapHelper/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TileMapHelper\"] = factory();\n\telse\n\t\troot[\"TileMapHelper\"] = factory();\n})((typeof self !== \"undefined\" ? self : this), function() {\nreturn ","import { integer, float } from \".\";\nimport { TiledMap } from \"./tiled/Tiled\";\nimport { EditableObjectLayer, EditableTileMap, EditableTileMapLayer } from \"./TileMapModel\";\nimport { TileTextureCache } from \"./TileTextureCache\";\n\nimport PIXI = GlobalPIXIModule.PIXI;\n\n    export class PixiTileMapHelper {\n      /**\n       * Parse a Tiled map JSON file,\n       * exported from Tiled (https://www.mapeditor.org/)\n       * into a generic tile map data (`GenericPixiTileMapData`).\n       *\n       * @param tiledData A JS object representing a map exported from Tiled.\n       * @param atlasTexture\n       * @param getTexture A getter to load a texture. Used if atlasTexture is not specified.\n       * @returns A textures cache.\n       */\n      static parseAtlas(\n        tiledData: TiledMap,\n        atlasTexture: PIXI.BaseTexture<PIXI.Resource> | null,\n        getTexture: (textureName: string) => PIXI.BaseTexture<PIXI.Resource>\n      ): TileTextureCache | null {\n        if (!tiledData.tiledversion) {\n          console.warn(\n            \"The loaded Tiled map does not contain a 'tiledversion' key. Are you sure this file has been exported from Tiled (mapeditor.org)?\"\n          );\n\n          return null;\n        }\n\n        // We only handle tileset embedded in the tilemap. Warn if it's not the case.\n        if (!tiledData.tilesets.length || 'source' in tiledData.tilesets[0]) {\n          console.warn(\n            \"The loaded Tiled map seems not to contain any tileset data (nothing in 'tilesets' key).\"\n          );\n          return null;\n        }\n\n        const {\n          tilewidth,\n          tileheight,\n          tilecount,\n          tiles,\n          image,\n          columns,\n          spacing,\n          margin,\n        } = tiledData.tilesets[0];\n        if (!atlasTexture) atlasTexture = getTexture(image);\n\n        // We try to detect what size Tiled is expecting.\n        const rows = tilecount / columns;\n        const expectedAtlasWidth =\n          tilewidth * columns + spacing * (columns - 1) + margin * 2;\n        const expectedAtlasHeight =\n          tileheight * rows + spacing * (rows - 1) + margin * 2;\n        if (\n          (atlasTexture.width !== 1 &&\n            expectedAtlasWidth !== atlasTexture.width) ||\n          (atlasTexture.height !== 1 &&\n            expectedAtlasHeight !== atlasTexture.height)\n        ) {\n          const expectedSize = expectedAtlasWidth + 'x' + expectedAtlasHeight;\n          const actualSize = atlasTexture.width + 'x' + atlasTexture.height;\n          console.warn(\n            'It seems the atlas file was resized, which is not supported. It should be ' +\n              expectedSize +\n              \"px, but it's \" +\n              actualSize +\n              ' px.'\n          );\n          return null;\n        }\n\n        // Prepare the textures pointing to the base \"Atlas\" Texture for each tile.\n        // Note that this cache can be augmented later with rotated/flipped\n        // versions of the tile textures.\n        const textureCache = new TileTextureCache();\n        for (let frame = 0; frame < tilecount; frame++) {\n          const columnMultiplier = Math.floor(frame % columns);\n          const rowMultiplier = Math.floor(frame / columns);\n          const x = margin + columnMultiplier * (tilewidth + spacing);\n          const y = margin + rowMultiplier * (tileheight + spacing);\n\n          try {\n            const rect = new PIXI.Rectangle(x, y, tilewidth, tileheight);\n            const texture = new PIXI.Texture(atlasTexture!, rect);\n\n            textureCache.setTexture(frame, false, false, false, texture);\n          } catch (error) {\n            console.error(\n              'An error occurred while creating a PIXI.Texture to be used in a TileMap:',\n              error\n            );\n          }\n        }\n\n        return textureCache;\n      }\n\n      /**\n       * Re-renders the tilemap whenever its rendering settings have been changed\n       *\n       * @param pixiTileMap\n       * @param tileMap\n       * @param textureCache\n       * @param displayMode What to display: only a single layer (`index`), only visible layers (`visible`) or everyhing (`all`).\n       * @param layerIndex If `displayMode` is set to `index`, the layer index to be displayed.\n       */\n      static updatePixiTileMap(\n        pixiTileMap : any,\n        tileMap: EditableTileMap,\n        textureCache: TileTextureCache,\n        displayMode: 'index' | 'visible' | 'all',\n        layerIndex: number\n      ) {\n        if (!pixiTileMap) return;\n        pixiTileMap.clear();\n\n        for (const layer of tileMap.getLayers()) {\n          if (\n            (displayMode === 'index' && layerIndex !== layer.id) ||\n            (displayMode === 'visible' && !layer.isVisible())\n          ) {\n            return;\n          }\n\n          if (layer instanceof EditableObjectLayer) {\n            const objectLayer = layer as EditableObjectLayer;\n            for (const object of objectLayer.objects) {\n              const texture = textureCache.findTileTexture(\n                object.getTileId(),\n                object.isFlippedHorizontally(),\n                object.isFlippedVertically(),\n                object.isFlippedDiagonally()\n              );\n              if (texture) {\n                pixiTileMap.addFrame(\n                  texture,\n                  object.x,\n                  object.y - objectLayer.tileMap.getTileHeight()\n                );\n              }\n            }\n          } else if (layer instanceof EditableTileMapLayer) {\n            const tileLayer = layer as EditableTileMapLayer;\n\n            for (let y = 0; y < tileLayer.tileMap.getDimensionY(); y++) {\n              for (let x = 0; x < tileLayer.tileMap.getDimensionX(); x++) {\n                const tileWidth = tileLayer.tileMap.getTileWidth();\n                const xPos = tileWidth * x;\n                const yPos = tileLayer.tileMap.getTileHeight() * y;\n\n                const tileId = tileLayer.get(x, y)!;\n\n                const tileTexture = textureCache.findTileTexture(\n                  tileId,\n                  tileLayer.isFlippedHorizontally(x, y),\n                  tileLayer.isFlippedVertically(x, y),\n                  tileLayer.isFlippedDiagonally(x, y)\n                );\n                if (tileTexture) {\n                  const pixiTilemapFrame = pixiTileMap.addFrame(\n                    tileTexture,\n                    xPos,\n                    yPos\n                  );\n\n                  const tileDefinition = tileLayer.tileMap.getTileDefinition(\n                    tileId\n                  );\n\n                  // Animated tiles have a limitation:\n                  // they are only able to use frames arranged horizontally one next\n                  // to each other on the atlas.\n                  if (\n                    tileDefinition &&\n                    tileDefinition.getAnimationLength() > 0\n                  ) {\n                    pixiTilemapFrame.tileAnimX(\n                      tileWidth,\n                      tileDefinition.getAnimationLength()\n                    );\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * Re-renders the collision mask\n       *\n       * @param pixiTileMap\n       * @param tileMap\n       * @param textureCache\n       * @param displayMode What to display: only a single layer (`index`), only visible layers (`visible`) or everyhing (`all`).\n       * @param layerIndex If `displayMode` is set to `index`, the layer index to be displayed.\n       */\n      static updatePixiCollisionMask(\n        pixiGraphics: PIXI.Graphics,\n        tileMap: EditableTileMap,\n        displayMode: 'index' | 'visible' | 'all',\n        layerIndex: integer,\n        typeFilter: string,\n        outlineSize: integer,\n        outlineColor: integer,\n        outlineOpacity: float,\n        fillColor: integer,\n        fillOpacity: float\n      ) {\n        if (!pixiGraphics) return;\n        pixiGraphics.clear();\n\n        for (const layer of tileMap.getLayers()) {\n          if (displayMode === 'index' && layerIndex !== layer.id) return;\n          // invisible doesn't mean no collision.\n          // TODO add a \"Enable\" flag next to \"Visible\" or rename \"Visible\" to \"Enable\"?\n          const tileWidth = tileMap.getTileWidth();\n          const tileHeight = tileMap.getTileHeight();\n\n          if (layer instanceof EditableTileMapLayer) {\n            const tileLayer = layer as EditableTileMapLayer;\n\n            for (let y = 0; y < tileLayer.tileMap.getDimensionY(); y++) {\n              for (let x = 0; x < tileLayer.tileMap.getDimensionX(); x++) {\n                const xPos = tileWidth * x;\n                const yPos = tileHeight * y;\n\n                const tileId = tileLayer.get(x, y)!;\n                const isFlippedHorizontally = tileLayer.isFlippedHorizontally(\n                  x,\n                  y\n                );\n                const isFlippedVertically = tileLayer.isFlippedVertically(x, y);\n                const isFlippedDiagonally = tileLayer.isFlippedDiagonally(x, y);\n                const tileDefinition = tileLayer.tileMap.getTileDefinition(\n                  tileId\n                );\n                if (!tileDefinition || tileDefinition.getTag() !== typeFilter) {\n                  continue;\n                }\n\n                pixiGraphics.lineStyle(\n                  outlineSize,\n                  outlineColor,\n                  outlineOpacity\n                );\n                for (const vertices of tileDefinition.getHiBoxes()) {\n                  if (vertices.length === 0) continue;\n\n                  pixiGraphics.beginFill(fillColor, fillOpacity);\n                  for (let index = 0; index < vertices.length; index++) {\n                    let vertexX = vertices[index][0];\n                    let vertexY = vertices[index][1];\n                    if (isFlippedHorizontally) {\n                      vertexX = tileWidth - vertexX;\n                    }\n                    if (isFlippedVertically) {\n                      vertexY = tileHeight - vertexY;\n                    }\n                    if (isFlippedDiagonally) {\n                      const swap = vertexX;\n                      vertexX = vertexY;\n                      vertexY = swap;\n                    }\n                    if (index === 0) {\n                      pixiGraphics.moveTo(xPos + vertexX, yPos + vertexY);\n                    } else {\n                      pixiGraphics.lineTo(xPos + vertexX, yPos + vertexY);\n                    }\n                  }\n                  pixiGraphics.closePath();\n                  pixiGraphics.endFill();\n                }\n              }\n            }\n          }\n        }\n      }\n    }","    export class ResourceCache<T> {\n      private _cachedValues: Map<string, T>;\n\n      private _callbacks: Map<string, Array<(value: T | null) => void>>;\n\n      /**\n       *\n       */\n      constructor() {\n        this._cachedValues = new Map<string, T>();\n        this._callbacks = new Map<string, Array<(value: T | null) => void>>();\n      }\n\n      getOrLoad(\n        key: string,\n        load: (callback: (value: T | null) => void) => void,\n        callback: (value: T | null) => void\n      ): void {\n        // Check if the value is in the cache.\n        {\n          const value = this._cachedValues.get(key);\n          if (value) {\n            callback(value);\n            return;\n          }\n        }\n        // Check if the value is being loading.\n        {\n          const callbacks = this._callbacks.get(key);\n          if (callbacks) {\n            callbacks.push(callback);\n            return;\n          } else {\n            this._callbacks.set(key, [callback]);\n          }\n        }\n\n        load((value) => {\n          if (value) {\n            this._cachedValues.set(key, value);\n          }\n          const callbacks = this._callbacks.get(key)!;\n          this._callbacks.delete(key);\n          for (const callback of callbacks) {\n            callback(value);\n          }\n        });\n      }\n    }","import { PixiTileMapHelper } from \".\";\nimport { ResourceCache } from \"./ResourceCache\";\nimport { TiledMap } from \"./tiled/Tiled\";\nimport { TiledTileMapLoader } from \"./tiled/TiledTileMapLoader\";\nimport { EditableTileMap } from \"./TileMapModel\";\nimport { TileTextureCache } from \"./TileTextureCache\";\n\nimport PIXI = GlobalPIXIModule.PIXI;\n\n    /**\n     * An holder to share tile maps across the 2 extension objects.\n     *\n     * Every instance with the same files path in properties will\n     * share the same {@link EditableTileMap} and {@link TileTextureCache}.\n     *\n     * @see {@link TileMapRuntimeManager}\n     */\n    export class TileMapManager {\n      private _tileMapCache: ResourceCache<\n        EditableTileMap\n      >;\n      private _textureCacheCaches: ResourceCache<\n        TileTextureCache\n      >;\n\n      /**\n       *\n       */\n      constructor() {\n        this._tileMapCache = new ResourceCache<\n          EditableTileMap\n        >();\n        this._textureCacheCaches = new ResourceCache<\n          TileTextureCache\n        >();\n      }\n\n      /**\n       * @param instanceHolder Where to set the manager instance.\n       * @returns The shared manager.\n       */\n      static getManager(instanceHolder: Object) {\n        // @ts-ignore\n        if (!instanceHolder.tileMapCollisionMaskManager) {\n          //Create the shared manager if necessary.\n          // @ts-ignore\n          instanceHolder.tileMapCollisionMaskManager = new TileMapManager();\n        }\n        // @ts-ignore\n        return instanceHolder.tileMapCollisionMaskManager;\n      }\n\n      /**\n       * @param loadTiledMap The method that loads the Tiled JSON file in memory.\n       * @param tilemapJsonFile\n       * @param tilesetJsonFile\n       * @param pako The zlib library.\n       * @param callback\n       */\n      getOrLoadTileMap(\n        loadTiledMap: (\n          tilemapJsonFile: string,\n          tilesetJsonFile: string,\n          callback: (tiledMap: TiledMap | null) => void\n        ) => void,\n        tilemapJsonFile: string,\n        tilesetJsonFile: string,\n        pako: any,\n        callback: (tileMap: EditableTileMap | null) => void\n      ): void {\n        const key = tilemapJsonFile + '|' + tilesetJsonFile;\n\n        this._tileMapCache.getOrLoad(\n          key,\n          (callback) => {\n            loadTiledMap(\n              tilemapJsonFile,\n              tilesetJsonFile,\n              (tiledMap: TiledMap | null) => {\n                if (!tiledMap) {\n                  callback(null);\n                  return;\n                }\n\n                const collisionTileMap = TiledTileMapLoader.load(\n                  pako,\n                  tiledMap\n                );\n                callback(collisionTileMap);\n              }\n            );\n          },\n          callback\n        );\n      }\n\n      /**\n       * @param loadTiledMap The method that loads the Tiled JSON file in memory.\n       * @param getTexture The method that loads the atlas image file in memory.\n       * @param atlasImageResourceName\n       * @param tilemapJsonFile\n       * @param tilesetJsonFile\n       * @param callback\n       */\n      getOrLoadTextureCache(\n        loadTiledMap: (\n          tilemapJsonFile: string,\n          tilesetJsonFile: string,\n          callback: (tiledMap: TiledMap | null) => void\n        ) => void,\n        getTexture: (textureName: string) => PIXI.BaseTexture<PIXI.Resource>,\n        atlasImageResourceName: string,\n        tilemapJsonFile: string,\n        tilesetJsonFile: string,\n        callback: (textureCache: TileTextureCache | null) => void\n      ): void {\n        const key =\n          tilemapJsonFile +\n          '|' +\n          tilesetJsonFile +\n          '|' +\n          atlasImageResourceName;\n\n        this._textureCacheCaches.getOrLoad(\n          key,\n          (callback) => {\n            loadTiledMap(\n              tilemapJsonFile,\n              tilesetJsonFile,\n              (tiledMap: TiledMap | null) => {\n                if (!tiledMap) {\n                  // loadTiledMap already log errors.\n                  callback(null);\n                  return;\n                }\n\n                const atlasTexture = atlasImageResourceName\n                  ? getTexture(atlasImageResourceName)\n                  : null;\n                const textureCache = PixiTileMapHelper.parseAtlas(\n                  tiledMap,\n                  atlasTexture,\n                  getTexture\n                );\n                callback(textureCache);\n              }\n            );\n          },\n          callback\n        );\n      }\n    }","import { FloatPoint, integer, float } from \".\";\n\n    export type PolygonVertices = FloatPoint[];\n    /**\n     * A tile map model.\n     *\n     * Tile map files are parsed into this model by {@link TiledTileMapLoader}.\n     * This model is used for rending ({@link TileMapRuntimeObjectPixiRenderer})\n     * and hitboxes handling ({@link TransformedCollisionTileMap}).\n     * This allows to support new file format with only a new parser.\n     */\n    export class EditableTileMap {\n      private _tileSet: Map<integer, TileDefinition>;\n      private _layers: Array<AbstractEditableLayer>;\n      /**\n       * The width of a tile.\n       */\n      private readonly tileWidth: integer;\n      /**\n       * The height of a tile.\n       */\n      private readonly tileHeight: integer;\n      /**\n       * The number of tile columns in the map.\n       */\n      private readonly dimX: integer;\n      /**\n       * The number of tile rows in the map.\n       */\n      private readonly dimY: integer;\n\n      /**\n       * @param tileWidth The width of a tile.\n       * @param tileHeight The height of a tile.\n       * @param dimX The number of tile columns in the map.\n       * @param dimY The number of tile rows in the map.\n       * @param tileSet The tile set.\n       */\n      constructor(\n        tileWidth: integer,\n        tileHeight: integer,\n        dimX: integer,\n        dimY: integer,\n        // TODO should the tile set be built internally?\n        // It's not meant to change and it avoid to do a copy.\n        tileSet: Map<integer, TileDefinition>\n      ) {\n        console.log('tile dimension: ' + tileWidth + ' ' + tileHeight);\n        this.tileWidth = tileWidth;\n        this.tileHeight = tileHeight;\n        this.dimX = dimX;\n        this.dimY = dimY;\n        this._tileSet = tileSet;\n        this._layers = [];\n      }\n\n      /**\n       * @returns The tile map width in pixels.\n       */\n      getWidth() {\n        return this.tileWidth * this.dimX;\n      }\n\n      /**\n       * @returns The tile map height in pixels.\n       */\n      getHeight() {\n        return this.tileHeight * this.dimY;\n      }\n\n      /**\n       * @returns The tile width in pixels.\n       */\n      getTileHeight() {\n        return this.tileWidth;\n      }\n\n      /**\n       * @returns The tile height in pixels.\n       */\n      getTileWidth() {\n        return this.tileHeight;\n      }\n\n      /**\n       * @returns The number of tile columns in the map.\n       */\n      getDimensionX() {\n        return this.dimX;\n      }\n\n      /**\n       * @returns The number of tile rows in the map.\n       */\n      getDimensionY() {\n        return this.dimY;\n      }\n\n      /**\n       * @param tileId The tile identifier\n       * @returns The tile definition form the tile set.\n       */\n      getTileDefinition(tileId: integer): TileDefinition | undefined {\n        return this._tileSet.get(tileId);\n      }\n\n      /**\n       * @returns All the tile definitions form the tile set.\n       */\n      getTileDefinitions(): Iterable<TileDefinition> {\n        return this._tileSet.values();\n      }\n\n      /**\n       * @param id The identifier of the new layer.\n       * @returns The new layer.\n       */\n      addTileLayer(id: integer): EditableTileMapLayer {\n        const layer = new EditableTileMapLayer(this, id);\n        this._layers.push(layer);\n        return layer;\n      }\n\n      /**\n       * @param id The identifier of the new layer.\n       * @returns The new layer.\n       */\n      addObjectLayer(id: integer): EditableObjectLayer {\n        const layer = new EditableObjectLayer(this, id);\n        this._layers.push(layer);\n        return layer;\n      }\n\n      /**\n       * @returns All the layers of the tile map.\n       */\n      getLayers(): Iterable<AbstractEditableLayer> {\n        return this._layers;\n      }\n\n      /**\n       * Check if a point is inside a tile with a given tag.\n       *\n       * It doesn't use the tile hitboxes.\n       * It only check the point is inside the tile square.\n       *\n       * @param x The X coordinate of the point to check.\n       * @param y The Y coordinate of the point to check.\n       * @param tag The tile tag\n       * @returns true when the point is inside a tile with a given tag.\n       */\n      pointIsInsideTile(x: float, y: float, tag: string): boolean {\n        const indexX = Math.floor(x / this.tileWidth);\n        const indexY = Math.floor(y / this.tileHeight);\n        for (const layer of this._layers) {\n          const tileLayer = layer as EditableTileMapLayer;\n          if (!tileLayer) {\n            continue;\n          }\n          const tileId = tileLayer.get(indexX, indexY);\n          if (!tileId) {\n            return false;\n          }\n          const tileDefinition = this._tileSet.get(tileId);\n          if (tileDefinition!.getTag() === tag) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n\n    /**\n     * A tile map layer.\n     */\n    abstract class AbstractEditableLayer {\n      /**\n       * The layer tile map.\n       */\n      readonly tileMap: EditableTileMap;\n      /**\n       * The layer identifier.\n       */\n      readonly id: integer;\n      private visible: boolean = true;\n\n      /**\n       * @param tileMap The layer tile map.\n       * @param id The layer identifier.\n       */\n      constructor(tileMap: EditableTileMap, id: integer) {\n        this.tileMap = tileMap;\n        this.id = id;\n      }\n\n      /**\n       * @param visible\n       */\n      setVisible(visible: boolean): void {\n        this.visible = visible;\n      }\n\n      /**\n       * @returns true if the layer is visible.\n       */\n      isVisible(): boolean {\n        return this.visible;\n      }\n    }\n\n    /**\n     * A layer where tiles are placed with pixel coordinates.\n     */\n    export class EditableObjectLayer extends AbstractEditableLayer {\n      readonly objects: TileObject[];\n\n      /**\n       * @param tileMap  The layer tile map.\n       * @param id The layer identifier.\n       */\n      constructor(tileMap: EditableTileMap, id: integer) {\n        super(tileMap, id);\n        this.objects = [];\n      }\n\n      /**\n       * @param object\n       */\n      add(object: TileObject) {\n        this.objects.push(object);\n      }\n    }\n\n    /**\n     * A tile that is placed with pixel coordinates.\n     */\n    export class TileObject {\n      /**\n       * The tile identifier in the tile set.\n       */\n      private tileId: integer;\n      /**\n       * The coordinate of the tile left side.\n       */\n      readonly x: float;\n      /**\n       * The coordinate of the tile top side.\n       */\n      readonly y: float;\n\n      /**\n       * @param x The coordinate of the tile left side.\n       * @param y The coordinate of the tile top side.\n       * @param tileId The tile identifier in the tile set.\n       */\n      constructor(x: float, y: float, tileId: integer) {\n        this.tileId = tileId;\n        this.x = x;\n        this.y = y;\n      }\n\n      /**\n       * @return The tile identifier in the tile set.\n       */\n      getTileId(): integer {\n        return FlippingHelper.getTileId(this.tileId);\n      }\n\n      /**\n       * @param flippedHorizontally\n       */\n      setFlippedHorizontally(flippedHorizontally: boolean) {\n        this.tileId = FlippingHelper.setFlippedHorizontally(\n          this.tileId,\n          flippedHorizontally\n        );\n      }\n\n      /**\n       * @param flippedVertically\n       */\n      setFlippedVertically(flippedVertically: boolean) {\n        this.tileId = FlippingHelper.setFlippedVertically(\n          this.tileId,\n          flippedVertically\n        );\n      }\n\n      /**\n       * @param flippedDiagonally\n       */\n      setFlippedDiagonally(flippedDiagonally: boolean) {\n        this.tileId = FlippingHelper.setFlippedDiagonally(\n          this.tileId,\n          flippedDiagonally\n        );\n      }\n\n      /**\n       * @returns true if the tile is flipped horizontally.\n       */\n      isFlippedHorizontally(): boolean {\n        return FlippingHelper.isFlippedHorizontally(this.tileId);\n      }\n\n      /**\n       * @returns true if the tile is flipped vertically.\n       */\n      isFlippedVertically(): boolean {\n        return FlippingHelper.isFlippedVertically(this.tileId);\n      }\n\n      /**\n       * @returns true if the tile is flipped diagonally.\n       */\n      isFlippedDiagonally(): boolean {\n        return FlippingHelper.isFlippedDiagonally(this.tileId);\n      }\n    }\n\n    /**\n     * Tile identifiers making to access flipping flags.\n     */\n    class FlippingHelper {\n      static readonly flippedHorizontallyFlag = 0x80000000;\n      static readonly flippedVerticallyFlag = 0x40000000;\n      static readonly flippedDiagonallyFlag = 0x20000000;\n      static readonly tileIdMask = ~(\n        FlippingHelper.flippedHorizontallyFlag |\n        FlippingHelper.flippedVerticallyFlag |\n        FlippingHelper.flippedDiagonallyFlag\n      );\n\n      static getTileId(tileId: integer): integer {\n        return tileId & FlippingHelper.tileIdMask;\n      }\n\n      static setFlippedHorizontally(\n        tileId: integer,\n        flippedHorizontally: boolean\n      ): integer {\n        tileId &= ~FlippingHelper.flippedHorizontallyFlag;\n        if (flippedHorizontally) {\n          tileId |= FlippingHelper.flippedHorizontallyFlag;\n        }\n        return tileId;\n      }\n\n      static setFlippedVertically(\n        tileId: integer,\n        flippedVertically: boolean\n      ): integer {\n        tileId &= ~FlippingHelper.flippedVerticallyFlag;\n        if (flippedVertically) {\n          tileId |= FlippingHelper.flippedVerticallyFlag;\n        }\n        return tileId;\n      }\n\n      static setFlippedDiagonally(\n        tileId: integer,\n        flippedDiagonally: boolean\n      ): integer {\n        tileId &= ~FlippingHelper.flippedDiagonallyFlag;\n        if (flippedDiagonally) {\n          tileId |= FlippingHelper.flippedDiagonallyFlag;\n        }\n        return tileId;\n      }\n\n      static isFlippedHorizontally(tileId: integer): boolean {\n        return (tileId & FlippingHelper.flippedHorizontallyFlag) !== 0;\n      }\n\n      static isFlippedVertically(tileId: integer): boolean {\n        return (tileId & FlippingHelper.flippedVerticallyFlag) !== 0;\n      }\n\n      static isFlippedDiagonally(tileId: integer): boolean {\n        return (tileId & FlippingHelper.flippedDiagonallyFlag) !== 0;\n      }\n    }\n\n    /**\n     * A tile map layer with tile organized in grid.\n     */\n    export class EditableTileMapLayer extends AbstractEditableLayer {\n      private readonly _tiles: Array<Int32Array>;\n\n      /**\n       * @param tileMap The layer tile map.\n       * @param id The layer identifier.\n       */\n      constructor(tileMap: EditableTileMap, id: integer) {\n        super(tileMap, id);\n        this._tiles = [];\n        this._tiles.length = this.tileMap.getDimensionY();\n        for (let index = 0; index < this._tiles.length; index++) {\n          this._tiles[index] = new Int32Array(this.tileMap.getDimensionX());\n        }\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @param tileId The tile identifier in the tile set.\n       */\n      setTile(x: integer, y: integer, tileId: integer): void {\n        const definition = this.tileMap.getTileDefinition(tileId);\n        if (!definition) {\n          throw new Error(`Invalid tile definition index: ${tileId}`);\n        }\n        //console.log(x + \" \" + y + \" set: \" + definitionIndex);\n        // +1 because 0 mean null\n        this._tiles[y][x] = tileId + 1;\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       */\n      removeTile(x: integer, y: integer): void {\n        // 0 mean null\n        this._tiles[y][x] = 0;\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @param flippedHorizontally\n       */\n      setFlippedHorizontally(\n        x: integer,\n        y: integer,\n        flippedHorizontally: boolean\n      ): void {\n        const tileId = this._tiles[y][x];\n        if (tileId === 0) {\n          return;\n        }\n        this._tiles[y][x] = FlippingHelper.setFlippedHorizontally(\n          tileId,\n          flippedHorizontally\n        );\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @param flippedVertically\n       */\n      setFlippedVertically(\n        x: integer,\n        y: integer,\n        flippedVertically: boolean\n      ): void {\n        const tileId = this._tiles[y][x];\n        if (tileId === 0) {\n          return;\n        }\n        this._tiles[y][x] = FlippingHelper.setFlippedVertically(\n          tileId,\n          flippedVertically\n        );\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @param flippedDiagonally\n       */\n      setFlippedDiagonally(\n        x: integer,\n        y: integer,\n        flippedDiagonally: boolean\n      ): void {\n        const tileId = this._tiles[y][x];\n        if (tileId === 0) {\n          return;\n        }\n        this._tiles[y][x] = FlippingHelper.setFlippedDiagonally(\n          tileId,\n          flippedDiagonally\n        );\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @returns true if the tile is flipped horizontally.\n       */\n      isFlippedHorizontally(x: integer, y: integer): boolean {\n        return FlippingHelper.isFlippedHorizontally(this._tiles[y][x]);\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @returns true if the tile is flipped vertically.\n       */\n      isFlippedVertically(x: integer, y: integer): boolean {\n        return FlippingHelper.isFlippedVertically(this._tiles[y][x]);\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @returns true if the tile is flipped diagonally.\n       */\n      isFlippedDiagonally(x: integer, y: integer): boolean {\n        return FlippingHelper.isFlippedDiagonally(this._tiles[y][x]);\n      }\n\n      /**\n       * @param x The layer column.\n       * @param y The layer row.\n       * @returns The tile identifier from the tile set.\n       */\n      get(x: integer, y: integer): integer | undefined {\n        const row = this._tiles[y];\n        if (!row || row[x] === 0) {\n          return undefined;\n        }\n        // -1 because 0 is keep for null.\n        const tileId = FlippingHelper.getTileId(row[x] - 1);\n        return tileId;\n      }\n\n      /**\n       * The number of tile columns in the layer.\n       */\n      getDimensionX() {\n        return this._tiles.length === 0 ? 0 : this._tiles[0].length;\n      }\n\n      /**\n       * The number of tile rows in the layer.\n       */\n      getDimensionY() {\n        return this._tiles.length;\n      }\n\n      /**\n       * @returns The layer width in pixels.\n       */\n      getWidth() {\n        return this.tileMap.getWidth();\n      }\n\n      /**\n       * @returns The layer height in pixels.\n       */\n      getHeight() {\n        return this.tileMap.getHeight();\n      }\n    }\n\n    /**\n     * A tile definition from the tile set.\n     */\n    export class TileDefinition {\n      private readonly hitBoxes: PolygonVertices[];\n      private readonly tag: string;\n      private readonly animationLength: integer;\n\n      /**\n       * @param hitBoxes The hit boxes for this tile.\n       * @param tag The tag of this tile.\n       * @param animationLength The number of frame in the tile animation.\n       */\n      constructor(\n        hitBoxes: PolygonVertices[],\n        tag: string,\n        animationLength: integer\n      ) {\n        this.hitBoxes = hitBoxes;\n        this.tag = tag;\n        this.animationLength = animationLength;\n      }\n\n      /**\n       * This property is used by {@link TransformedCollisionTileMap}\n       * to make collision classes.\n       * @returns The tag that is used to filter tiles.\n       */\n      getTag() {\n        return this.tag;\n      }\n\n      /**\n       * The hitboxes positioning is done by {@link TransformedCollisionTileMap}.\n       * @returns The hit boxes for this tile.\n       */\n      getHiBoxes() {\n        return this.hitBoxes;\n      }\n\n      /**\n       * Animated tiles have a limitation:\n       * they are only able to use frames arranged horizontally one next\n       * to each other on the atlas.\n       * @returns The number of frame in the tile animation.\n       */\n      getAnimationLength(): integer {\n        return this.animationLength;\n      }\n    }","import { integer } from \".\";\n\nimport PIXI = GlobalPIXIModule.PIXI;\n\n    /**\n     * A cache to access the tile images.\n     *\n     * It's created by {@link PixiTileMapHelper.parseAtlas}\n     * and used by {@link PixiTileMapHelper.updatePixiTileMap}.\n     */\n    export class TileTextureCache {\n      private static readonly flippedHorizontallyFlag = 0x80000000;\n      private static readonly flippedVerticallyFlag = 0x40000000;\n      private static readonly flippedDiagonallyFlag = 0x20000000;\n\n      private readonly _textures: Map<integer, PIXI.Texture>;\n\n      constructor() {\n        this._textures = new Map<integer, PIXI.Texture>();\n      }\n\n      setTexture(\n        tileId: integer,\n        flippedHorizontally: boolean,\n        flippedVertically: boolean,\n        flippedDiagonally: boolean,\n        texture: PIXI.Texture\n      ) {\n        let globalTileUid = this._getGlobalId(\n          tileId,\n          flippedHorizontally,\n          flippedVertically,\n          flippedDiagonally\n        );\n        this._textures.set(globalTileUid, texture);\n      }\n\n      /**\n       * Return the texture to use for the tile with the specified uid, which can contains\n       * information about rotation in bits 32, 31 and 30\n       * (see https://doc.mapeditor.org/en/stable/reference/tmx-map-format/).\n       *\n       * @param tileId The tile identifier\n       * @param flippedHorizontally\n       * @param flippedVertically\n       * @param flippedDiagonally\n       * @returns The texture for the given tile identifier and orientation.\n       */\n      findTileTexture(\n        tileId: integer,\n        flippedHorizontally: boolean,\n        flippedVertically: boolean,\n        flippedDiagonally: boolean\n      ): PIXI.Texture | undefined {\n        let globalTileUid = this._getGlobalId(\n          tileId,\n          flippedHorizontally,\n          flippedVertically,\n          flippedDiagonally\n        );\n        if (globalTileUid === 0) return undefined;\n\n        if (this._textures.has(globalTileUid)) {\n          return this._textures.get(globalTileUid);\n        }\n        // If the texture is not in the cache, it's potentially because its ID\n        // is a flipped/rotated version of another ID.\n        const unflippedTexture = this._textures.get(tileId);\n        // If the tile still can't be found in the cache, it means the ID we got\n        // is invalid.\n        if (!unflippedTexture) return undefined;\n\n        // Clone the unflipped texture and save it in the cache\n        const frame = unflippedTexture.frame.clone();\n        const orig = unflippedTexture.orig.clone();\n        if (flippedDiagonally) {\n          const width = orig.width;\n          orig.width = orig.height;\n          orig.height = width;\n        }\n        const trim = orig.clone();\n\n        // Get the rotation \"D8\" number.\n        // See https://pixijs.io/examples/#/textures/texture-rotate.js\n        let rotate = 0;\n        if (flippedDiagonally) {\n          rotate = 10;\n          if (!flippedHorizontally && flippedVertically) {\n            rotate = 2;\n          } else if (flippedHorizontally && !flippedVertically) {\n            rotate = 6;\n          } else if (flippedHorizontally && flippedVertically) {\n            rotate = 14;\n          }\n        } else {\n          rotate = 0;\n          if (!flippedHorizontally && flippedVertically) {\n            rotate = 8;\n          } else if (flippedHorizontally && !flippedVertically) {\n            rotate = 12;\n          } else if (flippedHorizontally && flippedVertically) {\n            rotate = 4;\n          }\n        }\n\n        const flippedTexture = new PIXI.Texture(\n          unflippedTexture.baseTexture,\n          frame,\n          orig,\n          trim,\n          rotate\n        );\n        this._textures.set(globalTileUid, flippedTexture);\n        return flippedTexture;\n      }\n\n      private _getGlobalId(\n        tileId: integer,\n        flippedHorizontally: boolean,\n        flippedVertically: boolean,\n        flippedDiagonally: boolean\n      ) {\n        let globalTileUid = tileId;\n        if (flippedHorizontally) {\n          globalTileUid |= TileTextureCache.flippedHorizontallyFlag;\n        }\n        if (flippedVertically) {\n          globalTileUid |= TileTextureCache.flippedVerticallyFlag;\n        }\n        if (flippedDiagonally) {\n          globalTileUid |= TileTextureCache.flippedDiagonallyFlag;\n        }\n        return globalTileUid;\n      }\n    }","/**\n * @packageDocumentation\n * @module TileMapHelper\n */\n\nimport { TileMapManager } from \"./TileMapManager\";\nimport { PixiTileMapHelper } from \"./PixiTileMapHelper\";\nimport { TiledMap, TiledTileset } from \"./tiled/Tiled\";\nimport { EditableTileMap, EditableTileMapLayer, TileDefinition } from \"./TileMapModel\";\nimport { TileTextureCache } from \"./TileTextureCache\";\n\nexport * from \"./CommonTypes\";\n\nexport { TileMapManager };\nexport { PixiTileMapHelper };\nexport { TileTextureCache };\n\nexport { EditableTileMap };\nexport { EditableTileMapLayer };\nexport { TileDefinition };\n\nexport { TiledMap };\nexport { TiledTileset };\n\n// TODO This should be added in the packaged library for the global import to work?\n//\n// const GlobalTileMapHelperModule = {\n//     TileMapManager,\n//     PixiTileMapHelper,\n//     EditableTileMap,\n//     EditableTileMapLayer,\n//     TileDefinition,\n//     TileTextureCache\n// }","import { integer } from \"../CommonTypes\";\nimport { TiledLayer } from \"./Tiled\";\n\n    /**\n     * Decodes a layer data, which can sometimes be store as a compressed base64 string\n     * by Tiled.\n     * See https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#data.\n     * @param pako The zlib library.\n     * @param layer The layer data from a Tiled JSON.\n     * @returns The decoded layer data.\n     */\n    export const decodeBase64LayerData = (pako: any, layer: TiledLayer) => {\n      const { data, compression } = layer;\n      const dataBase64 = data as string;\n      if (!dataBase64) {\n        // The layer data is not encoded.\n        return data as number[];\n      }\n      let index = 4;\n      const decodedData: integer[] = [];\n      let step1 = atob(dataBase64)\n        .split('')\n        .map(function (x) {\n          return x.charCodeAt(0);\n        });\n      try {\n        const decodeArray = (arr: integer[] | Uint8Array, index: integer) =>\n          (arr[index] +\n            (arr[index + 1] << 8) +\n            (arr[index + 2] << 16) +\n            (arr[index + 3] << 24)) >>>\n          0;\n\n        if (compression === 'zlib') {\n          const binData = new Uint8Array(step1);\n          const decompressedData = pako.inflate(binData);\n          while (index <= decompressedData.length) {\n            decodedData.push(decodeArray(decompressedData, index - 4));\n            index += 4;\n          }\n        } else if (compression === 'zstd') {\n          console.error(\n            'Zstandard compression is not supported for layers in a Tilemap. Use instead zlib compression or no compression.'\n          );\n          return null;\n        } else {\n          while (index <= step1.length) {\n            decodedData.push(decodeArray(step1, index - 4));\n            index += 4;\n          }\n        }\n        return decodedData;\n      } catch (error) {\n        console.error(\n          'Failed to decompress and unzip base64 layer.data string',\n          error\n        );\n        return null;\n      }\n    };\n\n    export type TiledGID = {\n      id: integer;\n      flippedHorizontally: boolean;\n      flippedVertically: boolean;\n      flippedDiagonally: boolean;\n    };\n\n    /**\n     * Extract information about the rotation of a tile from the tile id.\n     * @param globalTileUid\n     * @returns The tile identifier and orientation.\n     */\n    export const extractTileUidFlippedStates = (\n      globalTileUid: integer\n    ): TiledGID => {\n      const FLIPPED_HORIZONTALLY_FLAG = 0x80000000;\n      const FLIPPED_VERTICALLY_FLAG = 0x40000000;\n      const FLIPPED_DIAGONALLY_FLAG = 0x20000000;\n\n      const flippedHorizontally = globalTileUid & FLIPPED_HORIZONTALLY_FLAG;\n      const flippedVertically = globalTileUid & FLIPPED_VERTICALLY_FLAG;\n      const flippedDiagonally = globalTileUid & FLIPPED_DIAGONALLY_FLAG;\n      const tileUid =\n        globalTileUid &\n        ~(\n          FLIPPED_HORIZONTALLY_FLAG |\n          FLIPPED_VERTICALLY_FLAG |\n          FLIPPED_DIAGONALLY_FLAG\n        );\n\n      return {\n        id: tileUid,\n        flippedHorizontally: !!flippedHorizontally,\n        flippedVertically: !!flippedVertically,\n        flippedDiagonally: !!flippedDiagonally,\n      };\n    };","import { integer, PolygonVertices } from \"..\";\nimport { EditableTileMap, TileDefinition, TileObject } from \"../TileMapModel\";\nimport { TiledMap } from \"./Tiled\";\nimport { extractTileUidFlippedStates, decodeBase64LayerData } from \"./TiledLoaderHelper\";\n\n    /**\n     * It creates a {@link EditableTileMap} from a Tiled JSON.\n     */\n    export class TiledTileMapLoader {\n      static load(\n        pako: any,\n        tiledMap: TiledMap\n      ): EditableTileMap | null {\n        if (!tiledMap.tiledversion) {\n          console.warn(\n            \"The loaded Tiled map does not contain a 'tiledversion' key. Are you sure this file has been exported from Tiled (mapeditor.org)?\"\n          );\n\n          return null;\n        }\n\n        const definitions = new Map<integer, TileDefinition>();\n        for (const tile of tiledMap.tilesets[0].tiles!) {\n          const polygons: PolygonVertices[] = [];\n          if (tile.objectgroup) {\n            for (const object of tile.objectgroup.objects) {\n              let polygon: PolygonVertices | null = null;\n              if (object.polygon) {\n                polygon = object.polygon.map((point) => [point.x, point.y]);\n                //TODO check that polygons are convex or split them?\n              }\n              // TODO handle ellipses by creating a polygon?\n              // Make an object property for the number of vertices or always create 8 ones?\n              // Will the user need the same vertices number for every ellipse?\n              else {\n                polygon = [\n                  [object.x, object.y],\n                  [object.x, object.y + object.height],\n                  [object.x + object.width, object.y + object.height],\n                  [object.x + object.width, object.y],\n                ];\n              }\n              polygons.push(polygon);\n            }\n          }\n          //console.log(\"Definition: \" + tile.id);\n          definitions.set(\n            tile.id,\n            new TileDefinition(\n              polygons,\n              tile.type ? tile.type : '',\n              tile.animation ? tile.animation.length : 0\n            )\n          );\n        }\n        for (\n          let tileId = 0;\n          tileId < tiledMap.tilesets[0].tilecount;\n          tileId++\n        ) {\n          if (!definitions.has(tileId)) {\n            definitions.set(tileId, new TileDefinition([], '', 0));\n          }\n        }\n        //console.log(definitions.size + \" tiles definition\");\n        const collisionTileMap = new EditableTileMap(\n          tiledMap.tilewidth,\n          tiledMap.tileheight,\n          tiledMap.width,\n          tiledMap.height,\n          definitions\n        );\n\n        for (const tiledLayer of tiledMap.layers) {\n          if (tiledLayer.type === 'objectgroup') {\n            const objectLayer = collisionTileMap.addObjectLayer(tiledLayer.id);\n            objectLayer.setVisible(tiledLayer.visible);\n            for (const tiledObject of tiledLayer.objects) {\n              if (!tiledObject.visible) {\n                // Objects layer are nice to put decorations but dynamic objects\n                // must be done with GDevelop objects.\n                // So, there is no point to load it as there won't be any action to\n                // make objects visible individually.\n                continue;\n              }\n              const tileGid = extractTileUidFlippedStates(\n                tiledObject.gid\n              );\n              const object = new TileObject(\n                tiledObject.x,\n                tiledObject.y,\n                tileGid.id\n              );\n              objectLayer.add(object);\n              object.setFlippedHorizontally(tileGid.flippedHorizontally);\n              object.setFlippedVertically(tileGid.flippedVertically);\n              object.setFlippedDiagonally(tileGid.flippedDiagonally);\n            }\n          } else if (tiledLayer.type === 'tilelayer') {\n            let tileSlotIndex = 0;\n            let layerData: integer[] | null = null;\n\n            if (tiledLayer.encoding === 'base64') {\n              layerData = decodeBase64LayerData(pako, tiledLayer);\n              if (!layerData) {\n                console.warn('Failed to uncompress layer.data');\n              }\n            } else {\n              layerData = tiledLayer.data as integer[];\n            }\n            if (layerData) {\n              const collisionTileLayer = collisionTileMap.addTileLayer(\n                tiledLayer.id\n              );\n              collisionTileLayer.setVisible(tiledLayer.visible);\n              // TODO handle layer offset\n\n              for (let y = 0; y < tiledLayer.height; y++) {\n                for (let x = 0; x < tiledLayer.width; x++) {\n                  // The \"globalTileUid\" is the tile UID with encoded\n                  // bits about the flipping/rotation of the tile.\n                  const globalTileUid = layerData[tileSlotIndex];\n                  // Extract the tile UID and the texture.\n                  const tileUid = extractTileUidFlippedStates(\n                    globalTileUid\n                  );\n                  //console.log(\"globalTileUid: \" + tileUid.id + \" \" + tileUid.flippedHorizontally + \" \" + tileUid.flippedVertically + \" \" + tileUid.flippedDiagonally);\n                  if (tileUid.id > 0) {\n                    collisionTileLayer.setTile(x, y, tileUid.id - 1);\n                    collisionTileLayer.setFlippedHorizontally(\n                      x,\n                      y,\n                      tileUid.flippedHorizontally\n                    );\n                    collisionTileLayer.setFlippedVertically(\n                      x,\n                      y,\n                      tileUid.flippedVertically\n                    );\n                    collisionTileLayer.setFlippedDiagonally(\n                      x,\n                      y,\n                      tileUid.flippedDiagonally\n                    );\n                  }\n                  tileSlotIndex += 1;\n                }\n              }\n            }\n          }\n        }\n\n        return collisionTileMap;\n      }\n    }\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(303);\n"],"names":["root","factory","exports","module","define","amd","self","this","PIXI","GlobalPIXIModule","parseAtlas","tiledData","atlasTexture","getTexture","tiledversion","console","warn","tilesets","length","tilewidth","tileheight","tilecount","image","columns","spacing","margin","rows","expectedAtlasWidth","expectedAtlasHeight","width","height","expectedSize","actualSize","textureCache","TileTextureCache","frame","x","Math","floor","y","rect","Rectangle","texture","Texture","setTexture","error","updatePixiTileMap","pixiTileMap","tileMap","displayMode","layerIndex","clear","getLayers","layer","id","isVisible","EditableObjectLayer","objectLayer","objects","object","findTileTexture","getTileId","isFlippedHorizontally","isFlippedVertically","isFlippedDiagonally","addFrame","getTileHeight","EditableTileMapLayer","tileLayer","getDimensionY","getDimensionX","tileWidth","getTileWidth","xPos","yPos","tileId","get","tileTexture","pixiTilemapFrame","tileDefinition","getTileDefinition","getAnimationLength","tileAnimX","updatePixiCollisionMask","pixiGraphics","typeFilter","outlineSize","outlineColor","outlineOpacity","fillColor","fillOpacity","tileHeight","getTag","lineStyle","getHiBoxes","vertices","beginFill","index","vertexX","vertexY","swap","moveTo","lineTo","closePath","endFill","PixiTileMapHelper","_cachedValues","Map","_callbacks","getOrLoad","key","load","callback","value","callbacks","push","set","delete","ResourceCache","_tileMapCache","_textureCacheCaches","getManager","instanceHolder","tileMapCollisionMaskManager","TileMapManager","getOrLoadTileMap","loadTiledMap","tilemapJsonFile","tilesetJsonFile","pako","tiledMap","collisionTileMap","TiledTileMapLoader","getOrLoadTextureCache","atlasImageResourceName","dimX","dimY","tileSet","log","_tileSet","_layers","getWidth","getHeight","getTileDefinitions","values","addTileLayer","addObjectLayer","pointIsInsideTile","tag","indexX","indexY","EditableTileMap","visible","setVisible","add","AbstractEditableLayer","FlippingHelper","setFlippedHorizontally","flippedHorizontally","setFlippedVertically","flippedVertically","setFlippedDiagonally","flippedDiagonally","TileObject","tileIdMask","flippedHorizontallyFlag","flippedVerticallyFlag","flippedDiagonallyFlag","_tiles","Int32Array","setTile","Error","removeTile","row","hitBoxes","animationLength","TileDefinition","_textures","globalTileUid","_getGlobalId","has","unflippedTexture","clone","orig","trim","rotate","flippedTexture","baseTexture","decodeBase64LayerData","data","compression","decodedData","step1","atob","split","map","charCodeAt","decodeArray","arr","binData","Uint8Array","decompressedData","inflate","extractTileUidFlippedStates","definitions","tiles","tile","polygons","objectgroup","polygon","point","type","animation","layers","tiledLayer","tiledObject","tileGid","gid","tileSlotIndex","layerData","encoding","collisionTileLayer","tileUid","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}