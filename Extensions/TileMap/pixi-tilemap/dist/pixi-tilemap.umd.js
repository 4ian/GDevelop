(function(m,u){typeof exports=="object"&&typeof module<"u"?u(exports,require("@pixi/core"),require("@pixi/display")):typeof define=="function"&&define.amd?define(["exports","@pixi/core","@pixi/display"],u):(m=typeof globalThis<"u"?globalThis:m||self,u((m.PIXI=m.PIXI||{},m.PIXI.tilemap={}),m.PIXI,m.PIXI))})(this,function(m,u,V){"use strict";class D{constructor(t){this.tileAnim=[0,0],this.dontUseTransform=!1,this.renderer=t,this.tileAnim=[0,0]}static registerExtension(){u.extensions.add({name:"tilemap",type:u.ExtensionType.CanvasRendererPlugin,ref:D})}static getInstance(t){if(!t.plugins.tilemap)throw new Error("Extension not registered!");return t.plugins.tilemap}}const p={TEXTURES_PER_TILEMAP:16,TEXTILE_DIMEN:1024,TEXTILE_UNITS:1,TEXTILE_SCALE_MODE:u.SCALE_MODES.LINEAR,use32bitIndex:!1,DO_CLEAR:!0,get maxTextures(){return this.MAX_TEXTURES},set maxTextures(l){this.MAX_TEXTURES=l},get boundSize(){return this.TEXTURE_TILE_DIMEN},set boundSize(l){this.TILE_TEXTURE_DIMEN=l},get boundCountPerBuffer(){return this.TEXTILE_UNITS},set boundCountPerBuffer(l){this.TEXTILE_UNITS=l}},tt=p;var et=(l=>(l[l.U=0]="U",l[l.V=1]="V",l[l.X=2]="X",l[l.Y=3]="Y",l[l.TILE_WIDTH=4]="TILE_WIDTH",l[l.TILE_HEIGHT=5]="TILE_HEIGHT",l[l.ROTATE=6]="ROTATE",l[l.ANIM_X=7]="ANIM_X",l[l.ANIM_Y=8]="ANIM_Y",l[l.TEXTURE_INDEX=9]="TEXTURE_INDEX",l[l.ANIM_COUNT_X=10]="ANIM_COUNT_X",l[l.ANIM_COUNT_Y=11]="ANIM_COUNT_Y",l[l.ANIM_DIVISOR=12]="ANIM_DIVISOR",l[l.ALPHA=13]="ALPHA",l))(et||{});const y=Object.keys(et).length/2;class C extends V.Container{constructor(t){super(),this.shadowColor=new Float32Array([0,0,0,.5]),this._globalMat=null,this.tileAnim=null,this.modificationMarker=0,this.offsetX=0,this.offsetY=0,this.compositeParent=!1,this.tilemapBounds=new V.Bounds,this.hasAnimatedTile=!1,this.pointsBuf=[],this.renderCanvas=e=>{const i=D.getInstance(e);if(i&&!i.dontUseTransform){const s=this.worldTransform;e.canvasContext.activeContext.setTransform(s.a,s.b,s.c,s.d,s.tx*e.resolution,s.ty*e.resolution)}this.renderCanvasCore(e)},this.vbId=0,this.vb=null,this.vbBuffer=null,this.vbArray=null,this.vbInts=null,this.setTileset(t)}getTileset(){return this.tileset}setTileset(t=[]){Array.isArray(t)||(t=[t]);for(let e=0;e<t.length;e++)t[e].baseTexture&&(t[e]=t[e].baseTexture);return this.tileset=t,this}clear(){return this.pointsBuf.length=0,this.modificationMarker=0,this.tilemapBounds.clear(),this.hasAnimatedTile=!1,this}tile(t,e,i,s={}){let a,f=-1;if(typeof t=="number")f=t,a=this.tileset[f];else{let I;typeof t=="string"?I=u.Texture.from(t):I=t;const L=this.tileset;for(let b=0;b<L.length;b++)if(L[b]===I.castToBaseTexture()){f=b;break}"baseTexture"in I&&(s.u=s.u??I.frame.x,s.v=s.v??I.frame.y,s.tileWidth=s.tileWidth??I.orig.width,s.tileHeight=s.tileHeight??I.orig.height),a=I.castToBaseTexture()}if(!a||f<0)return console.error("The tile texture was not found in the tilemap tileset."),this;const{u:o=0,v:h=0,tileWidth:c=a.realWidth,tileHeight:d=a.realHeight,animX:g=0,animY:n=0,rotate:r=0,animCountX:M=1024,animCountY:B=1024,animDivisor:S=1,alpha:T=1}=s,v=this.pointsBuf;return this.hasAnimatedTile=this.hasAnimatedTile||g>0||n>0,v.push(o),v.push(h),v.push(e),v.push(i),v.push(c),v.push(d),v.push(r),v.push(g|0),v.push(n|0),v.push(f),v.push(M),v.push(B),v.push(S),v.push(T),this.tilemapBounds.addFramePad(e,i,e+c,i+d,0,0),this}tileRotate(t){const e=this.pointsBuf;e[e.length-(y-9)]=t}tileAnimX(t,e){const i=this.pointsBuf;i[i.length-(y-7)]=t,i[i.length-(y-10)]=e}tileAnimY(t,e){const i=this.pointsBuf;i[i.length-(y-8)]=t,i[i.length-(y-11)]=e}tileAnimDivisor(t){const e=this.pointsBuf;e[e.length-(y-12)]=t}tileAlpha(t){const e=this.pointsBuf;e[e.length-(y-13)]=t}renderCanvasCore(t){if(this.tileset.length===0)return;const e=this.pointsBuf,i=this.tileAnim||t.plugins.tilemap&&t.plugins.tilemap.tileAnim;t.canvasContext.activeContext.fillStyle="#000000";for(let s=0,a=e.length;s<a;s+=y){let f=e[s+0],o=e[s+1];const h=e[s+2],c=e[s+3],d=e[s+4],g=e[s+5];f+=e[s+7]*i[0],o+=e[s+8]*i[1];const n=e[s+9],r=e[s+13];n>=0&&this.tileset[n]?(t.canvasContext.activeContext.globalAlpha=r,t.canvasContext.activeContext.drawImage(this.tileset[n].getDrawableSource(),f,o,d,g,h,c,d,g)):(t.canvasContext.activeContext.globalAlpha=.5,t.canvasContext.activeContext.fillRect(h,c,d,g)),t.canvasContext.activeContext.globalAlpha=1}}destroyVb(){this.vb&&(this.vb.destroy(),this.vb=null)}render(t){const e=t.plugins.tilemap,i=e.getShader();t.batch.setObjectRenderer(e),this._globalMat=i.uniforms.projTransMatrix,t.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform),i.uniforms.shadowColor=this.shadowColor,i.uniforms.animationFrame=this.tileAnim||e.tileAnim,this.renderWebGLCore(t,e)}renderWebGLCore(t,e){const i=this.pointsBuf;if(i.length===0)return;const s=i.length/y,a=e.getShader(),f=this.tileset;if(f.length===0)return;e.bindTileTextures(t,f),t.shader.bind(a,!1);let o=this.vb;o||(o=e.createVb(),this.vb=o,this.vbId=o.id,this.vbBuffer=null,this.modificationMarker=0),e.checkIndexBuffer(s,o);const h=p.TEXTILE_UNITS,c=o.getBuffer("aVertexPosition"),d=s*o.vertPerQuad;if(d!==0){if(this.modificationMarker!==d){this.modificationMarker=d;const g=o.stride*d;if(!this.vbBuffer||this.vbBuffer.byteLength<g){let T=o.stride;for(;T<g;)T*=2;this.vbBuffer=new ArrayBuffer(T),this.vbArray=new Float32Array(this.vbBuffer),this.vbInts=new Uint32Array(this.vbBuffer),c.update(this.vbBuffer)}const n=this.vbArray;let r=0,M=0,B=this.offsetX,S=this.offsetY;for(let T=0;T<i.length;T+=y){if(this.compositeParent){const X=i[T+9];h>1?(M=X>>2,B=this.offsetX*(X&1),S=this.offsetY*(X>>1&1)):(M=X,B=0,S=0)}const I=i[T+2],L=i[T+3],b=i[T+4],_=i[T+5],x=i[T+0]+B,A=i[T+1]+S;let E=i[T+6];const ot=i[T+7],ht=i[T+8],ut=i[T+10]||1024,ft=i[T+11]||1024,N=ot+ut*2048,k=ht+ft*2048,H=i[T+12],U=i[T+13];let z,O,$,Q,q,K,Z,J;if(E===0)z=x,O=A,$=x+b,Q=A,q=x+b,K=A+_,Z=x,J=A+_;else{let X=b/2,w=_/2;E%4!==0&&(X=_/2,w=b/2);const W=x+X,j=A+w;E=u.groupD8.add(E,u.groupD8.NW),z=W+X*u.groupD8.uX(E),O=j+w*u.groupD8.uY(E),E=u.groupD8.add(E,2),$=W+X*u.groupD8.uX(E),Q=j+w*u.groupD8.uY(E),E=u.groupD8.add(E,2),q=W+X*u.groupD8.uX(E),K=j+w*u.groupD8.uY(E),E=u.groupD8.add(E,2),Z=W+X*u.groupD8.uX(E),J=j+w*u.groupD8.uY(E)}n[r++]=I,n[r++]=L,n[r++]=z,n[r++]=O,n[r++]=x+.5,n[r++]=A+.5,n[r++]=x+b-.5,n[r++]=A+_-.5,n[r++]=N,n[r++]=k,n[r++]=M,n[r++]=H,n[r++]=U,n[r++]=I+b,n[r++]=L,n[r++]=$,n[r++]=Q,n[r++]=x+.5,n[r++]=A+.5,n[r++]=x+b-.5,n[r++]=A+_-.5,n[r++]=N,n[r++]=k,n[r++]=M,n[r++]=H,n[r++]=U,n[r++]=I+b,n[r++]=L+_,n[r++]=q,n[r++]=K,n[r++]=x+.5,n[r++]=A+.5,n[r++]=x+b-.5,n[r++]=A+_-.5,n[r++]=N,n[r++]=k,n[r++]=M,n[r++]=H,n[r++]=U,n[r++]=I,n[r++]=L+_,n[r++]=Z,n[r++]=J,n[r++]=x+.5,n[r++]=A+.5,n[r++]=x+b-.5,n[r++]=A+_-.5,n[r++]=N,n[r++]=k,n[r++]=M,n[r++]=H,n[r++]=U}c.update(n)}t.geometry.bind(o,a),t.geometry.draw(u.DRAW_MODES.TRIANGLES,s*6,0)}}isModified(t){return!!(this.modificationMarker!==this.pointsBuf.length||t&&this.hasAnimatedTile)}clearModify(){this.modificationMarker=this.pointsBuf.length}_calculateBounds(){const{minX:t,minY:e,maxX:i,maxY:s}=this.tilemapBounds;this._bounds.addFrame(this.transform,t,e,i,s)}getLocalBounds(t){return this.children.length===0?this.tilemapBounds.getRectangle(t):super.getLocalBounds.call(this,t)}destroy(t){super.destroy(t),this.destroyVb()}addFrame(t,e,i,s,a){return this.tile(t,e,i,{animX:s,animY:a}),!0}addRect(t,e,i,s,a,f,o,h=0,c=0,d=0,g=1024,n=1024,r=1,M=1){return this.tile(t,s,a,{u:e,v:i,tileWidth:f,tileHeight:o,animX:h,animY:c,rotate:d,animCountX:g,animCountY:n,animDivisor:r,alpha:M})}}class F extends V.Container{constructor(t){super(),this.tileAnim=null,this.lastModifiedTilemap=null,this.modificationMarker=0,this.shadowColor=new Float32Array([0,0,0,.5]),this._globalMat=null,this.setBitmaps=this.tileset,this.tileset(t),this.texturesPerTilemap=p.TEXTURES_PER_TILEMAP}tileset(t){t||(t=[]);const e=this.texturesPerTilemap,i=this.children.length,s=Math.ceil(t.length/e);for(let a=0;a<Math.min(i,s);a++)this.children[a].setTileset(t.slice(a*e,(a+1)*e));for(let a=i;a<s;a++){const f=new C(t.slice(a*e,(a+1)*e));f.compositeParent=!0,f.offsetX=p.TEXTILE_DIMEN,f.offsetY=p.TEXTILE_DIMEN,this.addChild(f)}return this}clear(){for(let t=0;t<this.children.length;t++)this.children[t].clear();return this.modificationMarker=0,this}tileRotate(t){return this.lastModifiedTilemap&&this.lastModifiedTilemap.tileRotate(t),this}tileAnimX(t,e){return this.lastModifiedTilemap&&this.lastModifiedTilemap.tileAnimX(t,e),this}tileAnimY(t,e){return this.lastModifiedTilemap&&this.lastModifiedTilemap.tileAnimY(t,e),this}tileAnimDivisor(t){return this.lastModifiedTilemap&&this.lastModifiedTilemap.tileAnimDivisor(t),this}tile(t,e,i,s={}){let a=null;const f=this.children;if(this.lastModifiedTilemap=null,typeof t=="number"){const o=t/this.texturesPerTilemap>>0;let h=0;if(a=f[o],a)h=t%this.texturesPerTilemap;else{if(a=f[0],!a)return this;h=0}a.tile(h,e,i,s)}else{typeof t=="string"&&(t=u.Texture.from(t));for(let o=0;o<f.length;o++){const h=f[o],c=h.getTileset();for(let d=0;d<c.length;d++)if(c[d]===t.baseTexture){a=h;break}if(a)break}if(!a){for(let o=f.length-1;o>=0;o--){const h=f[o];if(h.getTileset().length<this.texturesPerTilemap){a=h,h.getTileset().push(t.baseTexture);break}}a||(a=new C(t.baseTexture),a.compositeParent=!0,a.offsetX=p.TEXTILE_DIMEN,a.offsetY=p.TEXTILE_DIMEN,this.addChild(a))}a.tile(t,e,i,s)}return this.lastModifiedTilemap=a,this}renderCanvas(t){if(!this.visible||this.worldAlpha<=0||!this.renderable)return;const e=D.getInstance(t);if(e&&!e.dontUseTransform){const s=this.worldTransform;t.canvasContext.activeContext.setTransform(s.a,s.b,s.c,s.d,s.tx*t.resolution,s.ty*t.resolution)}const i=this.children;for(let s=0;s<i.length;s++){const a=i[s];a.tileAnim=this.tileAnim,a.renderCanvasCore(t)}}render(t){if(!this.visible||this.worldAlpha<=0||!this.renderable)return;const e=t.plugins.tilemap,i=e.getShader();t.batch.setObjectRenderer(e),this._globalMat=i.uniforms.projTransMatrix,t.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform),i.uniforms.shadowColor=this.shadowColor,i.uniforms.animationFrame=this.tileAnim||e.tileAnim,t.shader.bind(i,!1);const s=this.children;for(let a=0;a<s.length;a++)s[a].renderWebGLCore(t,e)}isModified(t){const e=this.children;if(this.modificationMarker!==e.length)return!0;for(let i=0;i<e.length;i++)if(e[i].isModified(t))return!0;return!1}clearModify(){const t=this.children;this.modificationMarker=t.length;for(let e=0;e<t.length;e++)t[e].clearModify()}addFrame(t,e,i,s,a,f,o,h,c){return this.tile(t,e,i,{animX:s,animY:a,animCountX:f,animCountY:o,animDivisor:h,alpha:c})}addRect(t,e,i,s,a,f,o,h,c,d,g,n){const r=t/this.texturesPerTilemap>>0,M=t%this.texturesPerTilemap;return this.children[r]&&this.children[r].getTileset()?(this.lastModifiedTilemap=this.children[r],this.lastModifiedTilemap.addRect(M,e,i,s,a,f,o,h,c,d,g,n)):this.lastModifiedTilemap=null,this}get texPerChild(){return this.texturesPerTilemap}}class P extends u.Resource{constructor(t=p){super(t.TEXTILE_DIMEN*2,t.TEXTILE_DIMEN*Math.ceil(t.TEXTILE_UNITS/2)),this.baseTexture=null,this._clearBuffer=null;const e=this.tiles=new Array(t.TEXTILE_UNITS);this.doClear=!!t.DO_CLEAR,this.tileDimen=t.TEXTILE_DIMEN;for(let i=0;i<t.TEXTILE_UNITS;i++)e[i]={dirtyId:0,x:t.TEXTILE_DIMEN*(i&1),y:t.TEXTILE_DIMEN*(i>>1),baseTexture:u.Texture.WHITE.baseTexture}}tile(t,e){const i=this.tiles[t];i.baseTexture!==e&&(i.baseTexture=e,this.baseTexture.update(),this.tiles[t].dirtyId=this.baseTexture.dirtyId)}bind(t){if(this.baseTexture)throw new Error("Only one baseTexture is allowed for this resource!");this.baseTexture=t,super.bind(t)}upload(t,e,i){const{gl:s}=t,{width:a,height:f}=this;s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.alphaMode===void 0||e.alphaMode===u.ALPHA_MODES.UNPACK),i.dirtyId<0&&(i.width=a,i.height=f,s.texImage2D(e.target,0,e.format,a,f,0,e.format,e.type,null));const o=this.doClear,h=this.tiles;o&&!this._clearBuffer&&(this._clearBuffer=new Uint8Array(p.TEXTILE_DIMEN*p.TEXTILE_DIMEN*4));for(let c=0;c<h.length;c++){const d=h[c],g=d.baseTexture;if(i.dirtyId>=this.tiles[c].dirtyId)continue;const n=g.resource;!g.valid||!n||!n.source||(o&&(g.width<this.tileDimen||g.height<this.tileDimen)&&s.texSubImage2D(e.target,0,d.x,d.y,this.tileDimen,this.tileDimen,e.format,e.type,this._clearBuffer),s.texSubImage2D(e.target,0,d.x,d.y,e.format,e.type,n.source))}return!0}}function nt(l){let t="";t+=`
`,t+=`
`,t+="if(vTextureId <= -1.0) {",t+=`
	color = shadowColor;`,t+=`
}`;for(let e=0;e<l;e++)t+=`
else `,e<l-1&&(t+=`if(textureId == ${e}.0)`),t+=`
{`,t+=`
	color = texture2D(uSamplers[${e}], textureCoord * uSamplerSize[${e}]);`,t+=`
}`;return t+=`
`,t+=`
`,t}function it(l,t){const e=[];for(let s=0;s<t;s++)e[s]=s;l.uniforms.uSamplers=e;const i=[];for(let s=0;s<t;s++)i.push(1/2048),i.push(1/2048);l.uniforms.uSamplerSize=i}function st(l,t){return t.replace(/%count%/gi,`${l}`).replace(/%forloop%/gi,nt(l))}const rt=`#version 100
precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aFrame;
attribute vec2 aAnim;
attribute float aAnimDivisor;
attribute float aTextureId;
attribute float aAlpha;

uniform mat3 projTransMatrix;
uniform vec2 animationFrame;

varying vec2 vTextureCoord;
varying float vTextureId;
varying vec4 vFrame;
varying float vAlpha;

void main(void)
{
   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vec2 animCount = floor((aAnim + 0.5) / 2048.0);
   vec2 animFrameOffset = aAnim - animCount * 2048.0;
   vec2 currentFrame = floor(animationFrame / aAnimDivisor);
   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));

   vTextureCoord = aTextureCoord + animOffset;
   vFrame = aFrame + vec4(animOffset, animOffset);
   vTextureId = aTextureId;
   vAlpha = aAlpha;
}
`,at=`#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec2 vTextureCoord;
varying vec4 vFrame;
varying float vTextureId;
varying float vAlpha;
uniform vec4 shadowColor;
uniform sampler2D uSamplers[%count%];
uniform vec2 uSamplerSize[%count%];

void main(void)
{
   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);
   float textureId = floor(vTextureId + 0.5);

   vec4 color;
   %forloop%
   gl_FragColor = color * vAlpha;
}
`;class R extends u.Shader{constructor(t){super(new u.Program(rt,st(t,at)),{animationFrame:new Float32Array(2),uSamplers:[],uSamplerSize:[],projTransMatrix:new u.Matrix}),this.maxTextures=0,this.maxTextures=t,it(this,this.maxTextures)}}class Y extends u.Geometry{constructor(){super(),this.vertSize=13,this.vertPerQuad=4,this.stride=this.vertSize*4,this.lastTimeAccess=0;const t=this.buf=new u.Buffer(new Float32Array(2),!0,!1);this.addAttribute("aVertexPosition",t,0,!1,0,this.stride,0).addAttribute("aTextureCoord",t,0,!1,0,this.stride,2*4).addAttribute("aFrame",t,0,!1,0,this.stride,4*4).addAttribute("aAnim",t,0,!1,0,this.stride,8*4).addAttribute("aTextureId",t,0,!1,0,this.stride,10*4).addAttribute("aAnimDivisor",t,0,!1,0,this.stride,11*4).addAttribute("aAlpha",t,0,!1,0,this.stride,12*4)}}class G extends u.ObjectRenderer{constructor(t){super(t),this.tileAnim=[0,0],this.ibLen=0,this.indexBuffer=null,this.textiles=[],this.shader=new R(p.TEXTURES_PER_TILEMAP),this.indexBuffer=new u.Buffer(void 0,!0,!0),this.checkIndexBuffer(2e3),this.makeTextiles()}bindTileTextures(t,e){const i=e.length,s=this.shader,a=p.TEXTURES_PER_TILEMAP,f=s.uniforms.uSamplerSize;if(!(i>p.TEXTILE_UNITS*a)){if(p.TEXTILE_UNITS<=1)for(let o=0;o<e.length;o++){const h=e[o];if(!h||!h.valid)return;t.texture.bind(e[o],o),f[o*2]=1/e[o].realWidth,f[o*2+1]=1/e[o].realHeight}else{this.makeTextiles();const o=Math.ceil(i/p.TEXTILE_UNITS);for(let h=0;h<i;h++){const c=e[h];if(c&&c.valid){const d=Math.floor(h/p.TEXTILE_UNITS),g=h%p.TEXTILE_UNITS;this.textiles[d].tile(g,c)}}for(let h=0;h<o;h++)t.texture.bind(this.textiles[h].baseTexture,h),f[h*2]=1/this.textiles[h].width,f[h*2+1]=1/this.textiles[h].baseTexture.height}s.uniforms.uSamplerSize=f}}start(){}createVb(){const t=new Y;return t.addIndex(this.indexBuffer),t.lastTimeAccess=Date.now(),t}getShader(){return this.shader}destroy(){super.destroy(),this.shader=null}checkIndexBuffer(t,e=null){const i=t*6;i<=this.ibLen||(this.ibLen=i,this.indexBuffer.update(u.utils.createIndicesForQuads(t,p.use32bitIndex?new Uint32Array(t*6):void 0)))}makeTextiles(){if(!(p.TEXTILE_UNITS<=1))for(let t=0;t<p.TEXTILE_UNITS;t++){if(this.textiles[t])continue;const e=new P,i=new u.BaseTexture(e);i.scaleMode=p.TEXTILE_SCALE_MODE,i.wrapMode=u.WRAP_MODES.CLAMP,this.textiles[t]=e}}}const lt={CanvasTileRenderer:D,CompositeRectTileLayer:F,CompositeTilemap:F,Constant:tt,TextileResource:P,MultiTextureResource:P,RectTileLayer:C,Tilemap:C,TilemapShader:R,TilemapGeometry:Y,RectTileShader:R,RectTileGeom:Y,TileRenderer:G};u.extensions.add({name:"tilemap",type:u.ExtensionType.RendererPlugin,ref:G}),m.CanvasTileRenderer=D,m.CompositeRectTileLayer=F,m.CompositeTilemap=F,m.Constant=tt,m.POINT_STRUCT_SIZE=y,m.RectTileLayer=C,m.TextileResource=P,m.TileRenderer=G,m.Tilemap=C,m.TilemapGeometry=Y,m.TilemapShader=R,m.fillSamplers=it,m.generateFragmentSrc=st,m.pixi_tilemap=lt,m.settings=p,Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});
// Disabled to avoid warnings in Chrome (see https://github.com/4ian/GDevelop/pull/3947)
// //# sourceMappingURL=pixi-tilemap.umd.js.map
