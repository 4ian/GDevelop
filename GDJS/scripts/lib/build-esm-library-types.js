//@ts-check
const ts = require('typescript');
const path = require('path');
const { writeFile } = require('fs/promises');
const { readFileSync } = require('fs');

/**
 * {@link path.posix.relative} doesn't work as intended for some reason, so
 * just replace backslashes with slashes in case the script is ran on windows.
 *
 * @param {string} from
 * @param {string} to
 */
const relativePath = (from, to) => path.relative(from, to).replace(/\\/g, '/');

const gdevelopRootPath = path.join(__dirname, '..', '..', '..');
const gdevelopTypesDirectory = path.join(
  gdevelopRootPath,
  'GDJS',
  'Runtime',
  'types',
  'auto-generated'
);

/**
 * Generates a bundled dts for a module using the TypeScript programmatic API.
 * @param {string} pathToModule The path to the module to generate a dts from.
 * @returns {{mainDTS: string, bundledSubModules: string}} The DTS file contents as plain text.
 */
const generateDTS = (pathToModule) => {
  const mainModuleDirectoryName = path.dirname(pathToModule);
  const modulePrefix = path.basename(pathToModule, '.ts');
  const expectedMainModuleOutputName = pathToModule
    .replace('.ts', '.d.ts')
    .replace(/\\/g, '/');

  /**
   * By default, imports generated by tsc are relative, for example:
   * `import myFunction from "../OtherFolder/MyModule"`
   * Those are not good in our case, since modules names are treated like
   * an npm module name when using "declare module". We therefore have to
   * use a fixed AND unique module name.
   *
   * To do so, we first resolve the path name based on the root folder
   * ({@link mainModuleDirectoryName}) to use an absolute name that
   * won't change depending on the module importing it, and prefix it with
   * the main module name to avoid conflicts with the types definitions
   * of other ES modules.
   * @param {string} dtsContents
   * @param {string} pathToDTS
   */
  const rewriteImportsToAbsolutePathWithPrefix = (dtsContents, pathToDTS) => {
    let rewrittenDTS = dtsContents;

    for (const match of dtsContents.matchAll(
      /((export|import) .*) from ["'](\.?\.\/.*)["']/gm
    ))
      rewrittenDTS = rewrittenDTS.replace(
        match[0],
        `${match[1]} from '${modulePrefix}/${relativePath(
          mainModuleDirectoryName,
          `${mainModuleDirectoryName}/${pathToDTS}/${match[3]}`
        )}'`
      );

    return rewrittenDTS;
  };

  let mainDTS = '';
  let bundledSubModules = '';

  const program = ts.createProgram([pathToModule], {
    declaration: true,
    emitDeclarationOnly: true,
    typeRoots: [
      gdevelopTypesDirectory,
      path.join(gdevelopRootPath, 'GDJS', 'node_modules', '@types'),
    ],
  });
  const { diagnostics } = program.emit(
    undefined,
    (fileName, dts) => {
      if (fileName !== expectedMainModuleOutputName) {
        const moduleName = path
          .relative(mainModuleDirectoryName, fileName)
          .replace(/\\/g, '/')
          .replace('.d.ts', '');
        const modulePath = path.dirname(moduleName);
        const moduleFinalDTS = rewriteImportsToAbsolutePathWithPrefix(
          dts,
          modulePath
        ).replace(/declare /gm, '');
        bundledSubModules += `declare module "${modulePrefix}/${moduleName}" {${moduleFinalDTS}};\n\n`;
      } else {
        // This is the root module, we do not declare a module for it and just export it as the namespace.
        mainDTS = rewriteImportsToAbsolutePathWithPrefix(dts, './');
      }
    },
    undefined,
    true
  );

  if (diagnostics.length)
    console.error(
      ts.formatDiagnostics(
        ts.getPreEmitDiagnostics(program).concat(diagnostics),
        {
          getCanonicalFileName: (p) => path.join(mainModuleDirectoryName, p),
          getCurrentDirectory: () => gdevelopRootPath,
          getNewLine: () => ts.sys.newLine,
        }
      )
    );

  return { mainDTS, bundledSubModules };
};

module.exports = {
  /**
   * Generates types definitions for usage of bundled ES Modules in namespaced TypeScript.
   * @param {string[]} entryPoints The path relative to the root GDevelop folder to the module entry point.
   * @param {string} namespaceName The namespace in which to expose the module.
   * @returns {Promise<void>}
   */
  compileESModuleTypeDefinitions: async (entryPoints, namespaceName) => {
    const {
      accumulatedDTS: fullDTS,
      accumulatedBundledModules: fullBundledSubModules,
    } = entryPoints.reduce(
      ({ accumulatedDTS, accumulatedBundledModules }, modulePath) => {
        const { mainDTS, bundledSubModules } = generateDTS(modulePath);
        // Replace generated type definitions where a special flag comment has been written.
        // This is needed because TypeScript treats .d.ts files differently from source files,
        // and some syntax needs to be changed between them for them to be fully compatible.
        const finalDTS = mainDTS.replace(
          /\/\*\* TYPES_REPLACE \*\/\r?\n([^]*)\/\*\* WITH\r?\n([^]*)\r?\n\*\//gm,
          '$2'
        );

        return {
          accumulatedDTS: accumulatedDTS + finalDTS,
          accumulatedBundledModules:
            accumulatedBundledModules + bundledSubModules,
        };
      },
      {
        accumulatedDTS: '',
        accumulatedBundledModules: '',
      }
    );

    if (fullBundledSubModules)
      await writeFile(
        path.join(gdevelopTypesDirectory, `${namespaceName}-modules.d.ts`),
        `// Auto-generated types, see GDJS/scripts/lib/build-esm-library-types.js to modify those.\n${fullBundledSubModules}`
      );

    return writeFile(
      path.join(gdevelopTypesDirectory, `${namespaceName}-types.d.ts`),
      `// Auto-generated types, see GDJS/scripts/lib/build-esm-library-types.js to modify those.

${fullDTS}

export as namespace ${namespaceName}
`
    );
  },
};
