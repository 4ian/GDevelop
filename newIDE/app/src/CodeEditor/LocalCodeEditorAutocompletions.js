//@flow
import { findGDJS } from '../GameEngineFinder/LocalGDJSFinder';
import optionalRequire from '../Utils/OptionalRequire';
const fs = optionalRequire('fs');
const path = optionalRequire('path');

const excludedFiles = [
  'global-three.d.ts',
  'global-pixi.d.ts',
  'pixi-particles-pixi-renderer.d.ts',
  'pixi-tilemap.d.ts',
  'pixi.js',
  'three.js',
];

export const setupAutocompletions = (monaco: any) => {
  const importAllJsFilesFromFolder = (folderPath: string) =>
    fs.readdir(folderPath, (error: ?Error, filenames: Array<string>) => {
      if (error) {
        console.error(
          'Unable to read GDJS files for setting up autocompletions:',
          error
        );
        return;
      }

      filenames.forEach(filename => {
        const isDirectory = fs
          .lstatSync(path.join(folderPath, filename))
          .isDirectory();
        if (
          (filename.endsWith('.ts') || filename.endsWith('.js')) &&
          !excludedFiles.includes(filename) &&
          // Dialogue tree uses a folder called `bondage.js` that should not be read as a file.
          !isDirectory
        ) {
          const fullPath = path.join(folderPath, filename);
          fs.readFile(fullPath, 'utf8', (fileError, content) => {
            if (fileError) {
              console.error(
                `Unable to read ${fullPath} for setting up autocompletions:`,
                fileError
              );
              return;
            }

            monaco.languages.typescript.javascriptDefaults.addExtraLib(
              content,
              fullPath
            );
          });
        }
      });
    });

  const importAllJsFilesFromFolderRecursively = (folderPath: string) =>
    fs.readdir(folderPath, (error: ?Error, filenames: Array<string>) => {
      console.log('TEST');
      if (error) {
        console.error(
          'Unable to read GDJS files for setting up autocompletions:',
          error
        );
        return;
      }

      filenames.forEach(filename => {
        const fullPath = path.join(folderPath, filename);
        const isDirectory = fs.lstatSync(fullPath).isDirectory();
        if (isDirectory) {
          importAllJsFilesFromFolderRecursively(fullPath);
        } else if (filename.endsWith('.ts') || filename.endsWith('.js')) {
          fs.readFile(fullPath, 'utf8', (fileError, content) => {
            if (fileError) {
              console.error(
                `Unable to read ${fullPath} for setting up autocompletions:`,
                fileError
              );
              return;
            }

            monaco.languages.typescript.javascriptDefaults.addExtraLib(
              content,
              fullPath
            );
          });
        }
      });
    });

  findGDJS().then(({ gdjsRoot }) => {
    // Autocompletions are generated by reading the sources of the game engine
    // (much like how autocompletions work in Visual Studio Code) - *not* the built files.
    // The built files are stripped of their types and documentation, so it would
    // not work.
    //
    // We could also use the TypeScript compiler to emit .d.ts files when building GDJS,
    // but this would make TypeScript slower (at least 2x slower) and we would still need
    // to copy and read an equivalent number of files.
    const runtimePath = path.join(gdjsRoot, 'Runtime-sources');
    const runtimeTypesPath = path.join(runtimePath, 'types');
    const runtimeLibsPath = path.join(runtimePath, 'libs');
    const runtimePixiRenderersPath = path.join(runtimePath, 'pixi-renderers');
    const runtimeHowlerSoundManagerPath = path.join(
      runtimePath,
      'howler-sound-manager'
    );
    const runtimeFontfaceobserverFontManagerPath = path.join(
      runtimePath,
      'fontfaceobserver-font-manager'
    );
    const extensionsPath = path.join(runtimePath, 'Extensions');
    const eventToolsPath = path.join(runtimePath, 'events-tools');
    const threeTypesPath = path.join(runtimePath, 'three');
    const pixiTypesPath = path.join(runtimePath, 'pixi');

    importAllJsFilesFromFolder(runtimePath);
    importAllJsFilesFromFolder(runtimeTypesPath);
    importAllJsFilesFromFolder(runtimeLibsPath);
    importAllJsFilesFromFolder(runtimePixiRenderersPath);
    importAllJsFilesFromFolder(runtimeHowlerSoundManagerPath);
    importAllJsFilesFromFolder(runtimeFontfaceobserverFontManagerPath);
    importAllJsFilesFromFolder(eventToolsPath);
    importAllJsFilesFromFolderRecursively(threeTypesPath);

    importAllJsFilesFromFolderRecursively(pixiTypesPath);
    monaco.languages.typescript.javascriptDefaults.addExtraLib(
      `
  import './mixin-cache-as-bitmap/lib';
  import './mixin-get-child-by-name/lib';
  import './mixin-get-global-position/lib';
  export * from './accessibility/lib';
  export * from './app/lib';
  export * from './assets/lib';
  export * from './color/lib';
  export * from './compressed-textures/lib';
  export * from './constant/lib';
  export * from './core';
  export * from './display/lib';
  export * from './events/lib';
  export * from './extensions/lib';
  export * from './extract/lib';
  export * from './filter-alpha/lib';
  export * from './filter-blur/lib';
  export * from './filter-color-matrix/lib';
  export * from './filter-displacement/lib';
  export * from './filter-fxaa/lib';
  export * from './filter-noise/lib';
  export * from './graphics/lib';
  export * from './math/lib';
  export * from './mesh/lib';
  export * from './mesh-extras/lib';
  export * from './particle-container/lib';
  export * from './prepare/lib';
  export * from './runner/lib';
  export * from './settings/lib';
  export * from './sprite/lib';
  export * from './sprite-animated/lib';
  export * from './sprite-tiling/lib';
  export * from './spritesheet/lib';
  export * from './text/lib';
  export * from './text-bitmap/lib';
  export * from './text-html/lib';
  export * from './ticker/lib';
  export * from './utils/lib';
  
  export as namespace PIXI;
`,
      path.join(pixiTypesPath, 'index.d.ts')
    );

    fs.readdir(extensionsPath, (error: ?Error, folderNames: Array<string>) => {
      if (error) {
        console.error(
          'Unable to read Extensions folders for setting up autocompletions:',
          error
        );
        return;
      }

      folderNames
        .filter(
          folderName =>
            !folderName.endsWith('.txt') &&
            !folderName.endsWith('.md') &&
            !folderName.endsWith('.flow.js') &&
            !folderName.endsWith('.d.ts') &&
            !folderName.endsWith('.gitignore')
        )
        .forEach(folderName =>
          importAllJsFilesFromFolder(path.join(extensionsPath, folderName))
        );
    });

    monaco.languages.typescript.javascriptDefaults.addExtraLib(
      `
/** Represents the scene being played. */
var runtimeScene = new gdjs.RuntimeScene();

/**
 * The instances of objects that are passed to your JavaScript function.
 * @type {gdjs.RuntimeObject[]}
 */
var objects = [];

/**
 * @type {EventsFunctionContext}
 */
var eventsFunctionContext = {};
`,
      'this-mock-the-context-of-events.js'
    );
  });
};
